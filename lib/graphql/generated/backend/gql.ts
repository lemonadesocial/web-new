/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "query GetEvent($id: MongoID, $shortid: String) {\n  getEvent(_id: $id, shortid: $shortid) {\n    _id\n    title\n    description\n    approval_required\n    start\n    end\n    shortid\n    host\n    cohosts\n    host_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    accepted\n    new_new_photos_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    address_directions\n    subevent_enabled\n    sessions {\n      _id\n      start\n      end\n      broadcast\n      description\n      title\n      broadcast\n      photos_expanded {\n        _id\n        key\n        bucket\n      }\n      speaker_users\n      speaker_users_expanded {\n        ...User\n      }\n    }\n    space\n    space_expanded {\n      _id\n      title\n      image_avatar\n      image_avatar_expanded {\n        _id\n        bucket\n        url\n        type\n        key\n      }\n    }\n    timezone\n    application_questions {\n      _id\n      question\n      required\n      position\n      type\n      options\n      select_type\n    }\n    application_profile_fields {\n      field\n      question\n      required\n    }\n    self_verification {\n      config {\n        date_of_birth\n        excludedCountries\n        expiry_date\n        gender\n        issuing_state\n        minimumAge\n        name\n        nationality\n        ofac\n        passport_number\n      }\n      enabled\n    }\n    rsvp_wallet_platforms {\n      platform\n      required\n    }\n    calendar_links {\n      google\n      ical\n      outlook\n      yahoo\n    }\n    offers {\n      _id\n      provider\n      provider_id\n      provider_network\n    }\n    event_ticket_types {\n      _id\n      title\n      offers {\n        _id\n        provider_network\n        provider_id\n        provider\n      }\n    }\n    guest_limit\n    guest_limit_per\n    terms_text\n    virtual\n    virtual_url\n    theme_data\n    url\n    url_go\n    external_url\n    external_hostname\n    published\n    private\n    payment_accounts_new\n    payment_accounts_expanded {\n      ...PaymentAccount\n    }\n    layout_sections {\n      id\n      hidden\n    }\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n    hide_attending\n    registration_disabled\n    ticket_limit_per\n  }\n}\n\nquery GetEvents($subeventParent: MongoID, $skip: Int = 0, $limit: Int = 100, $id: [MongoID!], $site: MongoID, $search: String, $accepted: MongoID, $highlight: Boolean, $unpublished: Boolean, $startFrom: DateTimeISO, $startTo: DateTimeISO, $endFrom: DateTimeISO, $hostFilter: HostFilter, $sort: EventSortInput) {\n  getEvents(\n    subevent_parent: $subeventParent\n    skip: $skip\n    limit: $limit\n    _id: $id\n    site: $site\n    search: $search\n    accepted: $accepted\n    highlight: $highlight\n    unpublished: $unpublished\n    start_from: $startFrom\n    start_to: $startTo\n    end_from: $endFrom\n    host_filter: $hostFilter\n    sort: $sort\n  ) {\n    _id\n    shortid\n    title\n    host\n    host_expanded_new {\n      _id\n      name\n      image_avatar\n    }\n    cohosts\n    cohosts_expanded_new {\n      _id\n      name\n      image_avatar\n    }\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      url\n      type\n    }\n    start\n    end\n    timezone\n    event_ticket_types {\n      _id\n      title\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n    }\n    broadcasts {\n      provider_id\n    }\n    address {\n      title\n      city\n      title\n      region\n      additional_directions\n    }\n    accepted\n    sessions {\n      _id\n      broadcast\n      description\n      end\n      speaker_users\n      speaker_users_expanded {\n        _id\n        name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      start\n      title\n    }\n    subevent_parent_expanded {\n      _id\n      shortid\n      title\n      slug\n      start\n      timezone\n      new_new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n        type\n        url\n      }\n      subevent_settings {\n        ticket_required_for_creation\n        ticket_required_for_purchase\n      }\n    }\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    guests\n  }\n}\n\nquery GetUpcomingEvents($user: MongoID!, $limit: Int = 100, $skip: Int = 0, $host: Boolean, $sort: JSON, $site: MongoID, $unpublished: Boolean) {\n  events: getUpcomingEvents(\n    user: $user\n    limit: $limit\n    skip: $skip\n    host: $host\n    sort: $sort\n    site: $site\n    unpublished: $unpublished\n  ) {\n    _id\n    shortid\n    title\n    slug\n    host\n    host_expanded_new {\n      _id\n      name\n      new_photos_expanded {\n        _id\n        key\n        bucket\n      }\n    }\n    cohosts\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      type\n      url\n    }\n    start\n    end\n    timezone\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    me_awaiting_approval\n    published\n    private\n    guests\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n  }\n}\n\nquery GetPastEvents($user: MongoID!, $limit: Int = 100, $skip: Int = 0, $sort: JSON, $site: MongoID, $host: Boolean, $unpublished: Boolean) {\n  events: getPastEvents(\n    user: $user\n    limit: $limit\n    skip: $skip\n    sort: $sort\n    site: $site\n    host: $host\n    unpublished: $unpublished\n  ) {\n    _id\n    shortid\n    title\n    slug\n    host\n    host_expanded_new {\n      _id\n      name\n      new_photos_expanded {\n        _id\n        key\n        bucket\n      }\n    }\n    cohosts\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      type\n      url\n    }\n    start\n    end\n    timezone\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    me_awaiting_approval\n    published\n    private\n    guests\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n  }\n}\n\nquery getEventInvitation($event: MongoID!) {\n  getEventInvitation(event: $event) {\n    _id\n    inviters\n  }\n}\n\nquery GetEventTicketTypes($input: GetEventTicketTypesInput!) {\n  getEventTicketTypes(input: $input) {\n    ticket_types {\n      _id\n      title\n      default\n      description\n      event\n      limited\n      limit\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n      whitelisted\n      photos_expanded(limit: 1) {\n        _id\n        key\n        type\n        bucket\n      }\n      category\n      category_expanded {\n        _id\n        description\n        title\n        position\n      }\n      position\n      passcode_enabled\n      recommended_upgrade_ticket_types\n    }\n  }\n}\n\nquery getMyEventJoinRequest($event: MongoID!) {\n  getMyEventJoinRequest(event: $event) {\n    _id\n    created_at\n    decided_at\n    decided_by\n    decided_by_expanded {\n      _id\n      display_name\n      image_avatar\n      username\n      wallets\n    }\n    state\n    payment {\n      _id\n      state\n    }\n    requested_tickets {\n      count\n      ticket_type\n    }\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nmutation acceptEvent($id: MongoID!, $email: String) {\n  acceptEvent(_id: $id, email: $email) {\n    state\n  }\n}\n\nmutation SubmitEventApplicationAnswers($answers: [EventApplicationAnswerInput!]!, $event: MongoID!, $email: String) {\n  submitEventApplicationAnswers(answers: $answers, event: $event, email: $email)\n}\n\nquery PeekEventGuests($id: MongoID!, $limit: Int) {\n  peekEventGuests(_id: $id, limit: $limit) {\n    items {\n      _id\n      image_avatar\n      name\n      display_name\n      first_name\n    }\n    total\n  }\n}\n\nmutation UpdateEventTheme($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    theme_data\n  }\n}\n\nquery GetEventCohostInvites($input: GetEventCohostRequestsInput!) {\n  getEventCohostInvites(input: $input) {\n    event\n    from_expanded {\n      _id\n      name\n    }\n  }\n}\n\nmutation DecideEventCohostRequest($input: DecideEventCohostRequestInput!) {\n  decideEventCohostRequest(input: $input)\n}\n\nmutation createEvent($input: EventInput!) {\n  createEvent(input: $input) {\n    _id\n    shortid\n  }\n}\n\nmutation PublishEvent($event: MongoID!) {\n  updateEvent(_id: $event, input: {published: true}) {\n    _id\n    published\n  }\n}\n\nmutation UpdateEventSettings($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    title\n    description\n    start\n    end\n    timezone\n    theme_data\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    longitude\n    latitude\n    virtual_url\n    registration_disabled\n    guest_limit\n    terms_text\n    terms_link\n    shortid\n    private\n    layout_sections {\n      id\n      hidden\n    }\n  }\n}\n\nmutation UpdateEventPhotos($id: MongoID!, $new_new_photos: [MongoID!]) {\n  updateEvent(_id: $id, input: {new_new_photos: $new_new_photos}) {\n    new_new_photos\n    new_new_photos_expanded(limit: 50) {\n      _id\n      key\n      bucket\n    }\n  }\n}\n\nmutation inviteEvent($event: MongoID!, $users: [MongoID!], $emails: [String!], $custom_body_html: String) {\n  inviteEvent(\n    input: {_id: $event, users: $users, emails: $emails, custom_body_html: $custom_body_html}\n  ) {\n    _id\n    invited\n  }\n}\n\nmutation AssignTickets($input: AssignTicketsInput!) {\n  assignTickets(input: $input)\n}\n\nquery GetEventTicketSales($event: MongoID!) {\n  getEventTicketSales(event: $event) {\n    sales {\n      amount\n      currency\n      decimals\n    }\n    last_update\n  }\n}\n\nquery listEventTicketTypes($event: MongoID!) {\n  listEventTicketTypes(event: $event) {\n    limited_whitelist_users {\n      _id\n      email\n    }\n    _id\n    active\n    address_required\n    default\n    description\n    description_line\n    event\n    external_ids\n    limited\n    offers {\n      _id\n      auto\n      broadcast_rooms\n      position\n      provider\n      provider_id\n      provider_network\n    }\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n      type\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    private\n    ticket_count\n    ticket_limit\n    title\n    ticket_limit_per\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nquery ListEventTokenGates($event: MongoID!, $ticketTypes: [MongoID!]) {\n  listEventTokenGates(event: $event, ticket_types: $ticketTypes) {\n    _id\n    decimals\n    event\n    gated_ticket_types\n    is_nft\n    max_value\n    min_value\n    name\n    network\n    token_address\n  }\n}\n\nmutation CreateEventTokenGate($input: EventTokenGateInput!) {\n  createEventTokenGate(input: $input) {\n    _id\n  }\n}\n\nmutation UpdateEventTokenGate($input: EventTokenGateInput!) {\n  updateEventTokenGate(input: $input) {\n    _id\n  }\n}\n\nmutation ManageEventCohostRequests($input: ManageEventCohostRequestsInput!) {\n  manageEventCohostRequests(input: $input)\n}\n\nquery GetEventInvitedStatistics($id: MongoID!, $statuses: [InvitationResponse!], $limit: Float) {\n  getEventInvitedStatistics(_id: $id, statuses: $statuses, limit: $limit) {\n    emails_opened\n    guests {\n      user\n      pending\n      joined\n      email\n      declined\n      user_expanded {\n        _id\n        display_name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n    }\n    total\n    total_declined\n    total_joined\n  }\n}\n\nquery GetEventGuestsStatistics($event: MongoID!) {\n  getEventGuestsStatistics(event: $event) {\n    going\n    pending_approval\n    pending_invite\n    declined\n    checked_in\n  }\n}\n\nmutation UpdateEventRegistrationForm($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    rsvp_wallet_platforms {\n      platform\n      required\n    }\n  }\n}\n\nquery ListEventGuests($ticketTypes: [MongoID!], $going: Boolean, $pendingApproval: Boolean, $pendingInvite: Boolean, $declined: Boolean, $checkedIn: Boolean, $sortBy: ListEventGuestsSortBy, $sortOrder: SortOrder, $event: MongoID!, $search: String, $limit: Int, $skip: Int) {\n  listEventGuests(\n    ticket_types: $ticketTypes\n    going: $going\n    pending_approval: $pendingApproval\n    pending_invite: $pendingInvite\n    declined: $declined\n    checked_in: $checkedIn\n    sort_by: $sortBy\n    sort_order: $sortOrder\n    event: $event\n    search: $search\n    limit: $limit\n    skip: $skip\n  ) {\n    items {\n      join_request {\n        _id\n        state\n        non_login_user {\n          _id\n          display_name\n          email\n          image_avatar\n          name\n        }\n        user_expanded {\n          _id\n          display_name\n          email\n          image_avatar\n          name\n        }\n        metadata\n      }\n      ticket {\n        _id\n        created_at\n        type_expanded {\n          _id\n          title\n        }\n        metadata\n      }\n      user {\n        _id\n        display_name\n        email\n        image_avatar\n        name\n      }\n    }\n    total\n  }\n}\n\nquery GetEventGuestDetailedInfo($event: MongoID!, $email: String) {\n  getEventGuestDetailedInfo(event: $event, email: $email) {\n    checkin_count\n    purchased_tickets {\n      _id\n      type_expanded {\n        _id\n        title\n      }\n    }\n    ticket {\n      _id\n      created_at\n      type\n      type_expanded {\n        _id\n        title\n      }\n    }\n    user {\n      _id\n      description\n      display_name\n      email\n      first_name\n      image_avatar\n      last_name\n      name\n    }\n    payments {\n      _id\n      account_expanded {\n        ...PaymentAccount\n      }\n      amount\n      currency\n      crypto_payment_info {\n        network\n        tx_hash\n      }\n      stripe_payment_info {\n        card {\n          brand\n          last4\n        }\n        payment_intent\n      }\n      transfer_params\n      formatted_total_amount\n    }\n    join_request {\n      _id\n      state\n    }\n    application {\n      answer\n      answers\n      question\n    }\n  }\n}\n\nmutation submitEventApplicationQuestions($event: MongoID!, $questions: [QuestionInput!]!) {\n  submitEventApplicationQuestions(event: $event, questions: $questions) {\n    _id\n    question\n    required\n    position\n    type\n    options\n    select_type\n  }\n}\n\nmutation updateEventApplicationProfiles($fields: [ApplicationProfileFieldInput!], $id: MongoID!) {\n  updateEvent(input: {application_profile_fields: $fields}, _id: $id) {\n    application_profile_fields {\n      field\n      required\n      question\n    }\n  }\n}\n\nmutation decideUserJoinRequests($decision: EventJoinRequestState!, $event: MongoID!, $requests: [MongoID!]!) {\n  decideUserJoinRequests(\n    input: {decision: $decision, event: $event, requests: $requests}\n  ) {\n    _id\n    processed\n  }\n}\n\nquery getEventJoinRequests($event: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getEventJoinRequests(event: $event, skip: $skip, limit: $limit, state: $state) {\n    total\n    records {\n      _id\n      state\n      created_at\n      email\n      user\n      user_expanded {\n        _id\n        name\n        display_name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      non_login_user {\n        _id\n        name\n        email\n        display_name\n        username\n      }\n    }\n  }\n}\n\nquery GetListEventEmailSettings($event: MongoID!, $system: Boolean, $sent: Boolean, $scheduled: Boolean) {\n  listEventEmailSettings(\n    event: $event\n    system: $system\n    sent: $sent\n    scheduled: $scheduled\n  ) {\n    body_preview\n    _id\n    disabled\n    is_system_email\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    owner_expanded {\n      _id\n      image_avatar\n      new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n      }\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    scheduled_at\n    sent_at\n    subject_preview\n    type\n    custom_body_html\n    custom_subject_html\n    opened {\n      email\n      stamp\n    }\n  }\n}\n\nmutation UpdateEventEmailSetting($input: UpdateEventEmailSettingInput!) {\n  updateEventEmailSetting(input: $input) {\n    _id\n    body_preview\n    is_system_email\n    disabled\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    owner_expanded {\n      image_avatar\n    }\n    scheduled_at\n    sent_at\n    subject_preview\n    type\n    custom_body_html\n    custom_subject_html\n    template\n  }\n}\n\nmutation CreateEventEmailSetting($input: CreateEventEmailSettingInput!) {\n  createEventEmailSetting(input: $input) {\n    _id\n    body_preview\n    cc\n    custom_body_html\n    context\n    custom_subject_html\n    disabled\n    is_system_email\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    owner_expanded {\n      image_avatar\n    }\n    scheduled_at\n    sendgrid_template_id\n    sent_at\n    subject_preview\n    template\n    type\n    opened {\n      email\n      stamp\n    }\n  }\n}\n\nmutation DeleteEventEmailSetting($id: MongoID!) {\n  deleteEventEmailSetting(_id: $id)\n}\n\nmutation SendEventEmailSettingTestEmails($input: SendEventEmailSettingTestEmailsInput!) {\n  sendEventEmailSettingTestEmails(input: $input)\n}\n\nmutation ToggleEventEmailSettings($disabled: Boolean!, $ids: [MongoID!]!, $event: MongoID!) {\n  toggleEventEmailSettings(disabled: $disabled, ids: $ids, event: $event)\n}\n\nmutation UpdateEventToggleAttending($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    hide_attending\n  }\n}\n\nquery GetTickets($event: MongoID, $user: MongoID, $ticket_types: [MongoID!], $email: String) {\n  getTickets(\n    event: $event\n    user: $user\n    ticket_types: $ticket_types\n    email: $email\n  ) {\n    _id\n    accepted\n    assigned_email\n    assigned_to\n    assigned_to_expanded {\n      _id\n      name\n      new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n      }\n    }\n    event\n    invited_by\n    type\n    shortid\n  }\n}\n\nmutation CreatePoapDrop($input: CreatePoapInput!) {\n  createPoapDrop(input: $input) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nquery ListPoapDrops($event: MongoID!) {\n  listPoapDrops(event: $event) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n    minting_network\n  }\n}\n\nquery ListMyPoapClaims($event: MongoID) {\n  listMyPoapClaims(event: $event) {\n    drop {\n      _id\n    }\n    claimed_date\n  }\n}\n\nquery getEventCheckInState($id: MongoID) {\n  getEvent(_id: $id) {\n    checkedin\n  }\n}\n\nmutation ClaimPoap($wallet: String!, $drop: MongoID!) {\n  claimPoap(wallet: $wallet, drop: $drop)\n}\n\nmutation UpdatePoapDrop($input: UpdatePoapInput!, $drop: MongoID!) {\n  updatePoapDrop(input: $input, drop: $drop) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nquery GetPoapDropInfoById($getPoapDropInfoByIdId: Float!) {\n  getPoapDropInfoById(id: $getPoapDropInfoByIdId) {\n    description\n    image_url\n    name\n  }\n}\n\nquery CheckPoapDropEditCode($code: String!, $checkPoapDropEditCodeId: Int!) {\n  checkPoapDropEditCode(code: $code, id: $checkPoapDropEditCodeId)\n}\n\nmutation ImportPoapDrop($input: ImportPoapInput!, $code: String!, $importPoapDropId: Float!) {\n  importPoapDrop(input: $input, code: $code, id: $importPoapDropId) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nmutation CancelEvent($event: MongoID!) {\n  cancelEvent(_id: $event) {\n    _id\n  }\n}\n\nmutation cloneEvent($input: CloneEventInput!) {\n  cloneEvent(input: $input)\n}\n\nquery GenerateRecurringDates($input: GenerateRecurringDatesInput!) {\n  generateRecurringDates(input: $input)\n}\n\nmutation CreateEventTicketDiscounts($event: MongoID!, $inputs: [EventPaymentTicketDiscountInput!]!) {\n  createEventTicketDiscounts(event: $event, inputs: $inputs) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation UpdateEventTicketDiscount($event: MongoID!, $input: UpdateEventTicketDiscountInput!) {\n  updateEventTicketDiscount(event: $event, input: $input) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation DeleteEventTicketDiscounts($event: MongoID!, $discounts: [String!]!) {\n  deleteEventTicketDiscounts(event: $event, discounts: $discounts) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation UpdateEventSelfVerification($id: MongoID!, $self_verification: SelfVerificationInput) {\n  updateEvent(_id: $id, input: {self_verification: $self_verification}) {\n    self_verification {\n      config {\n        date_of_birth\n        excludedCountries\n        expiry_date\n        gender\n        issuing_state\n        minimumAge\n        name\n        nationality\n        ofac\n        passport_number\n      }\n      enabled\n    }\n  }\n}\n\nquery GetEventPaymentStatistics($event: MongoID!) {\n  getEventPaymentStatistics(event: $event) {\n    total_payments\n    stripe_payments {\n      count\n      revenue {\n        currency\n        formatted_total_amount\n      }\n    }\n    crypto_payments {\n      count\n      revenue {\n        currency\n        formatted_total_amount\n      }\n      networks {\n        chain_id\n        count\n      }\n    }\n  }\n}\n\nquery GetListEventPayments($skip: Int, $limit: Int, $event: MongoID!, $provider: NewPaymentProvider, $networks: [String!], $checked_in: Boolean, $ticket_types: [MongoID!], $search: String) {\n  listEventPayments(\n    skip: $skip\n    limit: $limit\n    event: $event\n    provider: $provider\n    networks: $networks\n    checked_in: $checked_in\n    ticket_types: $ticket_types\n    search: $search\n  ) {\n    records {\n      _id\n      account_expanded {\n        provider\n      }\n      stripe_payment_info {\n        payment_intent\n        card {\n          last4\n          brand\n        }\n      }\n      application {\n        question\n        answer\n      }\n      buyer_info {\n        email\n        name\n      }\n      buyer_user {\n        email\n        display_name\n        name\n        image_avatar\n      }\n      amount\n      currency\n      due_amount\n      fee\n      formatted_total_amount\n      formatted_discount_amount\n      currency\n      user\n      stamps\n      ticket_types_expanded {\n        _id\n        category_expanded {\n          title\n        }\n      }\n      state\n      account_expanded {\n        _id\n        active\n        created_at\n        user\n        type\n        title\n        provider\n      }\n      ref_data\n      transfer_params\n      transfer_metadata\n      crypto_payment_info {\n        network\n        tx_hash\n      }\n    }\n    total\n  }\n}\n\nquery getTicketStatistics($id: MongoID!) {\n  getTicketStatistics(id: $id) {\n    all\n    checked_in\n    invited\n    issued\n    cancelled\n    applicants {\n      state\n      count\n    }\n    not_checked_in\n    ticket_types {\n      ticket_type\n      ticket_type_title\n      count\n    }\n  }\n}": typeof types.GetEventDocument,
    "query GetSystemFiles($categories: [FileCategory!]) {\n  getSystemFiles(categories: $categories) {\n    _id\n    name\n    category\n    url\n    type\n    bucket\n    key\n  }\n}\n\nmutation createFileUploads($uploadInfos: [FileUploadInfo!]!, $directory: String!) {\n  createFileUploads(upload_infos: $uploadInfos, directory: $directory) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    presignedUrl: presigned_url\n  }\n}\n\nmutation confirmFileUploads($ids: [MongoID!]!) {\n  confirmFileUploads(ids: $ids)\n}\n\nmutation updateFileDescriptionMutation($input: FileInput!, $id: MongoID!) {\n  updateFile(input: $input, _id: $id) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    description\n  }\n}": typeof types.GetSystemFilesDocument,
    "fragment User on User {\n  _id\n  name\n  display_name\n  first_name\n  last_name\n  username\n  description\n  job_title\n  company_name\n  addresses {\n    _id\n    street_1\n    street_2\n    city\n    region\n    postal\n    country\n    title\n    phone\n    longitude\n    latitude\n    additional_directions\n  }\n  icebreakers {\n    _id\n    value\n    question_expanded {\n      _id\n      title\n    }\n  }\n  handle_facebook\n  handle_instagram\n  handle_linkedin\n  handle_twitter\n  handle_farcaster\n  handle_github\n  pronoun\n  calendly_url\n  website\n  new_photos_expanded(limit: 1) {\n    _id\n    key\n    bucket\n  }\n  url\n  url_go\n  lens_profile_synced\n  followers\n  following\n  hosted\n}\n\nfragment PaymentAccount on NewPaymentAccount {\n  _id\n  provider\n  type\n  title\n  account_info {\n    ... on EthereumAccount {\n      currencies\n      currency_map\n      address\n      network\n    }\n    ... on SafeAccount {\n      currencies\n      currency_map\n      address\n      network\n      owners\n      threshold\n      pending\n    }\n    ... on DigitalAccount {\n      currencies\n      currency_map\n      account_id\n    }\n    ... on StripeAccount {\n      currencies\n      currency_map\n      account_id\n      publishable_key\n    }\n    ... on EthereumEscrowAccount {\n      currencies\n      currency_map\n      address\n      network\n      minimum_deposit_percent\n      host_refund_percent\n      refund_policies {\n        percent\n        timestamp\n      }\n    }\n    ... on EthereumRelayAccount {\n      currencies\n      currency_map\n      address\n      network\n      payment_splitter_contract\n    }\n    ... on EthereumStakeAccount {\n      currencies\n      currency_map\n      address\n      network\n      config_id\n      requirement_checkin_before\n    }\n    ... on SolanaAccount {\n      currencies\n      currency_map\n      address\n      network\n    }\n  }\n}\n\nfragment AccountInfoFragment on AccountInfo {\n  ... on EthereumAccount {\n    currencies\n    currency_map\n    address\n    network\n  }\n  ... on SafeAccount {\n    currencies\n    currency_map\n    address\n    network\n    owners\n    threshold\n    pending\n  }\n  ... on DigitalAccount {\n    currencies\n    currency_map\n    account_id\n  }\n  ... on StripeAccount {\n    currencies\n    currency_map\n    account_id\n    publishable_key\n  }\n  ... on EthereumEscrowAccount {\n    currencies\n    currency_map\n    address\n    network\n    minimum_deposit_percent\n    host_refund_percent\n    refund_policies {\n      percent\n      timestamp\n    }\n  }\n  ... on EthereumRelayAccount {\n    currencies\n    currency_map\n    address\n    network\n    payment_splitter_contract\n  }\n  ... on EthereumStakeAccount {\n    currencies\n    currency_map\n    address\n    network\n    config_id\n    requirement_checkin_before\n  }\n  ... on SolanaAccount {\n    currencies\n    currency_map\n    address\n    network\n  }\n}": typeof types.UserFragmentDoc,
    "query ListLaunchpadGroups($address: String, $search: String) {\n  listLaunchpadGroups(address: $address, search: $search) {\n    items {\n      address\n      cover_photo\n      cover_photo_expanded {\n        _id\n        key\n        bucket\n      }\n      cover_photo_url\n      implementation_address\n      name\n    }\n  }\n}\n\nmutation AddLaunchpadCoin($input: LaunchpadCoinInput!) {\n  addLaunchpadCoin(input: $input) {\n    address\n  }\n}\n\nmutation AddLaunchpadGroup($input: AddLaunchpadGroupInput!) {\n  addLaunchpadGroup(input: $input) {\n    address\n  }\n}\n\nquery Items($skip: Int, $limit: Int, $address: String) {\n  listLaunchpadCoins(skip: $skip, limit: $limit, address: $address) {\n    items {\n      handle_telegram\n      handle_discord\n      handle_farcaster\n      handle_twitter\n      address\n      owner\n      website\n    }\n  }\n}": typeof types.ListLaunchpadGroupsDocument,
    "query GetListLemonheadSponsors($wallet: String!) {\n  listLemonheadSponsors(wallet: $wallet) {\n    sponsors {\n      limit\n      sponsor {\n        _id\n        name\n        image_url\n        message\n      }\n      remaining\n    }\n  }\n}\n\nquery CanMintLemonhead($wallet: String!) {\n  canMintLemonhead(wallet: $wallet) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}\n\nquery CanMintPassport($wallet: String!, $provider: PassportProvider!) {\n  canMintPassport(wallet: $wallet, provider: $provider) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}\n\nquery GetListMyLemonheadInvitations {\n  listMyLemonheadInvitations {\n    invitations {\n      invitee_wallet\n      minted_at\n      user {\n        _id\n        username\n        image_avatar\n      }\n    }\n  }\n}\n\nquery GetMyLemonheadInvitationRank {\n  getMyLemonheadInvitationRank {\n    rank\n    user {\n      _id\n      name\n      display_name\n      username\n      image_avatar\n      lemonhead_inviter_wallet\n      kratos_wallet_address\n    }\n    invitations_count\n  }\n}\n\nquery GetLemonheadInvitationRank($skip: Int!, $limit: Int!) {\n  getLemonheadInvitationRank(skip: $skip, limit: $limit) {\n    items {\n      rank\n      user {\n        _id\n        name\n        display_name\n        username\n        image_avatar\n        lemonhead_inviter_wallet\n        kratos_wallet_address\n      }\n      invitations_count\n    }\n    total\n  }\n}\n\nmutation SetUserWallet($token: String!, $signature: String!) {\n  setUserWallet(token: $token, signature: $signature)\n}\n\nmutation UpdateMyLemonheadInvitations($invitations: [String!]!) {\n  updateMyLemonheadInvitations(invitations: $invitations) {\n    success\n    message\n    wallets\n  }\n}": typeof types.GetListLemonheadSponsorsDocument,
    "query listChains {\n  listChains {\n    active\n    platform\n    chain_id\n    name\n    code_name\n    rpc_url\n    block_explorer_url\n    block_explorer_name\n    block_explorer_for_tx\n    block_explorer_for_token\n    block_explorer_for_address\n    block_explorer_icon_url\n    block_time\n    safe_confirmations\n    logo_url\n    tokens {\n      active\n      name\n      symbol\n      decimals\n      contract\n      logo_url\n      is_native\n    }\n    access_registry_contract\n    poap_contract\n    marketplace_contract\n    marketplace_version\n    biconomy_api_key\n    ens_registry\n    proxy_admin_contract\n    payment_config_registry_contract\n    escrow_manager_contract\n    relay_payment_contract\n    stake_payment_contract\n    reward_registry_contract\n    eas_event_contract\n    eas_graphql_url\n    aragon_network\n    axelar_chain_name\n    donation_registry_contract\n    lemonhead_contract_address\n    lemonade_passport_contract_address\n    zugrama_passport_contract_address\n    vinyl_nation_passport_contract_address\n    drip_nation_passport_contract_address\n    festival_nation_passport_contract_address\n    lemonade_username_contract_address\n    poap_enabled\n    launchpad_closed_permissions_contract_address\n    launchpad_treasury_address_fee_split_manager_implementation_contract_address\n    launchpad_treasury_staking_manager_implementation_contract_address\n    launchpad_zap_contract_address\n    launchpad_fee_escrow_contract_address\n    launchpad_market_capped_price_contract_address\n    launchpad_market_utils_contract_address\n  }\n}\n\nquery GetUserWalletRequest($wallet: String!) {\n  getUserWalletRequest(wallet: $wallet) {\n    message\n    token\n  }\n}\n\nmutation createFileUploads($uploadInfos: [FileUploadInfo!]!, $directory: String!) {\n  createFileUploads(upload_infos: $uploadInfos, directory: $directory) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    presignedUrl: presigned_url\n  }\n}\n\nquery GetSelfVerificationStatus($config: SelfVerificationConfigInput!) {\n  getSelfVerificationStatus(config: $config) {\n    disclosures {\n      type\n      verified\n    }\n  }\n}\n\nmutation CreateSelfVerificationRequest($config: SelfVerificationConfigInput!) {\n  createSelfVerificationRequest(config: $config) {\n    endpoint\n    endpoint_type\n    scope\n    uuid\n  }\n}": typeof types.ListChainsDocument,
    "mutation CreateOauth2Client($input: Oauth2ClientInput!) {\n  createOauth2Client(input: $input) {\n    client_id\n    client_secret\n    audience\n  }\n}": typeof types.CreateOauth2ClientDocument,
    "query CanMintPassport($wallet: String!, $provider: PassportProvider!) {\n  canMintPassport(wallet: $wallet, provider: $provider) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}": typeof types.CanMintPassportDocument,
    "mutation createStripeCard($paymentMethod: String!) {\n  createStripeCard(payment_method: $paymentMethod) {\n    _id\n    provider_id\n  }\n}\n\nquery getStripeCards {\n  getStripeCards {\n    _id\n    active\n    brand\n    last4\n    name\n    provider_id\n    stamp\n    user\n  }\n}\n\nmutation updatePayment($input: UpdatePaymentInput!) {\n  updatePayment(input: $input) {\n    _id\n    transfer_metadata\n    state\n    failure_reason\n  }\n}\n\nquery getNewPayment($id: MongoID!, $paymentSecret: String) {\n  getNewPayment(_id: $id, payment_secret: $paymentSecret) {\n    _id\n    due_amount\n    amount\n    currency\n    ref_data\n    state\n    failure_reason\n    account_expanded {\n      _id\n      type\n      account_info {\n        ... on EthereumEscrowAccount {\n          currencies\n          currency_map\n          address\n          network\n          minimum_deposit_percent\n          host_refund_percent\n          refund_policies {\n            percent\n            timestamp\n          }\n        }\n      }\n    }\n  }\n}\n\nquery getPaymentRefundSignature($id: MongoID!) {\n  getPaymentRefundSignature(_id: $id) {\n    args\n    signature\n  }\n}\n\nmutation CancelPayment($input: CancelPaymentInput!) {\n  cancelPayment(input: $input)\n}\n\nmutation GenerateStripeAccountLink($refreshUrl: String!, $returnUrl: String!) {\n  generateStripeAccountLink(refresh_url: $refreshUrl, return_url: $returnUrl) {\n    url\n  }\n}\n\nquery listNewPaymentAccounts($id: [MongoID!], $type: PaymentAccountType, $provider: NewPaymentProvider) {\n  listNewPaymentAccounts(_id: $id, type: $type, provider: $provider) {\n    _id\n    account_info {\n      ...AccountInfoFragment\n    }\n    active\n    provider\n    created_at\n    type\n    user\n    title\n  }\n}\n\nmutation createNewPaymentAccount($type: PaymentAccountType!, $provider: NewPaymentProvider, $account_info: JSON) {\n  createNewPaymentAccount(\n    input: {type: $type, provider: $provider, account_info: $account_info}\n  ) {\n    _id\n    account_info {\n      ...AccountInfoFragment\n    }\n    active\n    provider\n    created_at\n    type\n    user\n    title\n  }\n}\n\nmutation updateEventPaymentAccounts($id: MongoID!, $payment_accounts_new: [MongoID!]) {\n  updateEvent(_id: $id, input: {payment_accounts_new: $payment_accounts_new}) {\n    payment_accounts_new\n    payment_accounts_expanded {\n      ...PaymentAccount\n    }\n  }\n}": typeof types.CreateStripeCardDocument,
    "fragment Space on Space {\n  _id\n  title\n  admins {\n    _id\n    image_avatar\n  }\n  description\n  is_ambassador\n  followed\n  followers\n  followers_count\n  image_avatar\n  image_avatar_expanded {\n    _id\n    bucket\n    url\n    type\n    key\n  }\n  image_cover\n  image_cover_expanded {\n    _id\n    bucket\n    url\n    type\n    key\n  }\n  creator\n  creator_expanded {\n    _id\n    name\n    image_avatar\n  }\n  slug\n  private\n  listed_events\n  website\n  address {\n    _id\n    city\n    country\n    latitude\n    longitude\n    street_1\n    street_2\n    region\n    title\n  }\n  handle_instagram\n  handle_twitter\n  handle_linkedin\n  handle_youtube\n  handle_tiktok\n  personal\n  theme_data\n  sub_spaces\n  lens_feed_id\n  council_members {\n    user {\n      _id\n      display_name\n      username\n      image_avatar\n    }\n    wallet\n  }\n  state\n}\n\nfragment SpaceTagFragment on SpaceTag {\n  _id\n  color\n  space\n  tag\n  targets\n  type\n}\n\nfragment SpaceEventRequestFragment on SpaceEventRequest {\n  _id\n  created_at\n  space\n  event\n  state\n  decided_at\n  decided_by\n}\n\nquery GetSpaces($with_my_spaces: Boolean, $with_public_spaces: Boolean, $roles: [SpaceRole!], $featured: Boolean) {\n  listSpaces(\n    with_my_spaces: $with_my_spaces\n    with_public_spaces: $with_public_spaces\n    roles: $roles\n    featured: $featured\n  ) {\n    ...Space\n  }\n}\n\nquery GetSpace($id: MongoID, $slug: String, $hostname: String) {\n  getSpace(_id: $id, slug: $slug, hostname: $hostname) {\n    ...Space\n  }\n}\n\nquery GetSpaceEvents($skip: Int, $limit: Int, $startFrom: DateTimeISO, $startTo: DateTimeISO, $space: MongoID, $sort: EventSortInput, $endFrom: DateTimeISO, $endTo: DateTimeISO, $spaceTags: [MongoID!]) {\n  getEvents(\n    skip: $skip\n    limit: $limit\n    start_from: $startFrom\n    start_to: $startTo\n    space: $space\n    sort: $sort\n    end_from: $endFrom\n    end_to: $endTo\n    space_tags: $spaceTags\n  ) {\n    _id\n    shortid\n    title\n    host_expanded_new {\n      _id\n      image_avatar\n      name\n    }\n    visible_cohosts_expanded_new {\n      _id\n      image_avatar\n      name\n    }\n    address {\n      city\n      country\n      region\n      latitude\n      longitude\n    }\n    new_new_photos_expanded {\n      _id\n      bucket\n      key\n      type\n      url\n    }\n    published\n    start\n    end\n    timezone\n    external_url\n    external_hostname\n    event_ticket_types {\n      _id\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n    }\n    host_expanded_new {\n      _id\n      image_avatar\n    }\n    visible_cohosts_expanded_new {\n      _id\n      image_avatar\n    }\n  }\n}\n\nquery GetSpaceEventsCalendar($space: MongoID) {\n  getEvents(space: $space) {\n    _id\n    start\n    address {\n      _id\n      latitude\n      longitude\n    }\n  }\n}\n\nquery GetSpaceTags($space: MongoID!) {\n  listSpaceTags(space: $space) {\n    ...SpaceTagFragment\n  }\n}\n\nquery GetSpaceEventRequests($space: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getSpaceEventRequests(space: $space, skip: $skip, limit: $limit, state: $state) {\n    records {\n      _id\n      created_at\n      space\n      event\n      state\n      decided_at\n      decided_by\n      created_by_expanded {\n        name\n        display_name\n        email\n      }\n      event_expanded {\n        title\n        start\n        timezone\n        address {\n          city\n          country\n          region\n        }\n        new_new_photos_expanded {\n          _id\n          bucket\n          key\n          type\n          url\n        }\n        guests\n      }\n    }\n    total\n  }\n}\n\nquery GetMySpaceEventRequests($space: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getMySpaceEventRequests(\n    space: $space\n    skip: $skip\n    limit: $limit\n    state: $state\n  ) {\n    records {\n      _id\n      state\n      event_expanded {\n        _id\n        title\n        new_new_photos_expanded {\n          key\n          bucket\n          _id\n          url\n          type\n        }\n      }\n    }\n  }\n}\n\nquery getSubSpaces($id: MongoID!) {\n  getSubSpaces(_id: $id) {\n    _id\n    title\n    description\n    followers_count\n    slug\n    is_admin\n    followed\n    image_avatar_expanded {\n      _id\n      bucket\n      url\n      type\n      key\n    }\n  }\n}\n\nquery GetListSpaceCategories {\n  listSpaceCategories {\n    description\n    image_url\n    listed_events_count\n    space\n    title\n  }\n}\n\nquery GetListGeoRegions {\n  listGeoRegions {\n    _id\n    title\n    cities {\n      name\n      region\n      space\n      icon_url\n      listed_events_count\n    }\n  }\n}\n\nquery CheckSpaceSlug($slug: String!) {\n  canUseSpaceSlug(slug: $slug)\n}\n\nquery SearchSpaces($skip: Int, $limit: Int, $input: SearchSpaceInput) {\n  searchSpaces(input: $input, limit: $limit, skip: $skip) {\n    items {\n      ...Space\n    }\n    total\n  }\n}\n\nquery GetSpaceMembers($space: MongoID!, $roles: [SpaceRole!], $state: SpaceMembershipState, $visible: Boolean, $skip: Int, $limit: Int, $search: String, $sort: SortInput, $deletion: Boolean, $tags: [MongoID!]) {\n  listSpaceMembers(\n    space: $space\n    roles: $roles\n    state: $state\n    visible: $visible\n    skip: $skip\n    limit: $limit\n    search: $search\n    sort: $sort\n    deletion: $deletion\n    tags: $tags\n  ) {\n    total\n    items {\n      _id\n      user\n      user_name\n      email\n      space\n      role\n      state\n      visible\n      role_changed_at\n      deleted_at\n      user_expanded {\n        _id\n        name\n        display_name\n        email\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      event_count\n      checkin_count\n      tags {\n        _id\n        space\n        tag\n        color\n        type\n        targets\n        targets_count\n      }\n    }\n  }\n}\n\nmutation FollowSpace($space: MongoID!) {\n  followSpace(space: $space)\n}\n\nmutation UnfollowSpace($space: MongoID!) {\n  unfollowSpace(space: $space)\n}\n\nmutation UpdateSpace($id: MongoID!, $input: SpaceInput!) {\n  updateSpace(_id: $id, input: $input) {\n    ...Space\n  }\n}\n\nmutation PinEventsToSpace($space: MongoID!, $events: [MongoID!]!, $tags: [MongoID!]) {\n  pinEventsToSpace(space: $space, events: $events, tags: $tags) {\n    requests {\n      ...SpaceEventRequestFragment\n    }\n  }\n}\n\nmutation CreateExternalEvent($input: EventInput!) {\n  createEvent(input: $input) {\n    _id\n  }\n}\n\nmutation CreateSpace($input: SpaceInput!) {\n  createSpace(input: $input) {\n    ...Space\n  }\n}\n\nmutation DecideSpaceEventRequests($input: DecideSpaceEventRequestsInput!) {\n  decideSpaceEventRequests(input: $input)\n}\n\nmutation AddSpaceMembers($input: AddSpaceMemberInput!) {\n  addSpaceMembers(input: $input)\n}\n\nmutation DeleteSpaceMembers($input: DeleteSpaceMemberInput!) {\n  deleteSpaceMembers(input: $input) {\n    _id\n    role\n    state\n    user\n    user_name\n    email\n    deleted_at\n    role_changed_at\n    user_expanded {\n      _id\n      name\n      email\n      image_avatar\n    }\n    visible\n  }\n}\n\nmutation DeleteSpace($id: MongoID!) {\n  deleteSpace(_id: $id)\n}\n\nmutation UpsertSpaceTag($input: SpaceTagInput!) {\n  insertSpaceTag(input: $input) {\n    ...SpaceTagFragment\n  }\n}\n\nmutation ManageSpaceTag($tagged: Boolean!, $target: String!, $id: MongoID!, $space: MongoID!) {\n  manageSpaceTag(tagged: $tagged, target: $target, _id: $id, space: $space)\n}\n\nmutation DeleteSpaceTag($id: MongoID!, $space: MongoID!) {\n  deleteSpaceTag(_id: $id, space: $space)\n}\n\nmutation AttachSubSpaces($id: MongoID!, $subSpaces: [String!]!) {\n  attachSubSpaces(_id: $id, sub_spaces: $subSpaces)\n}\n\nmutation RemoveSubSpaces($subSpaces: [MongoID!]!, $id: MongoID!) {\n  removeSubSpaces(sub_spaces: $subSpaces, _id: $id)\n}\n\nmutation UpdateSubSpaceOrder($id: MongoID!, $subSpaces: [MongoID!]!) {\n  updateSubSpaceOrder(_id: $id, sub_spaces: $subSpaces)\n}\n\nmutation UpsertSpaceTag($input: SpaceTagInput!) {\n  insertSpaceTag(input: $input) {\n    ...SpaceTagFragment\n  }\n}\n\nmutation DeleteSpaceTag($id: MongoID!, $space: MongoID!) {\n  deleteSpaceTag(_id: $id, space: $space)\n}": typeof types.SpaceFragmentDoc,
    "query CalculateTicketsPricing($input: CalculateTicketsPricingInput!) {\n  calculateTicketsPricing(input: $input) {\n    deposit_infos {\n      minimum_amount\n      minimum_percent\n    }\n    discount\n    payment_accounts {\n      _id\n      account_info {\n        ... on SolanaAccount {\n          currencies\n          currency_map\n          address\n          network\n        }\n        ... on EthereumAccount {\n          currencies\n          currency_map\n          address\n          network\n        }\n        ... on SafeAccount {\n          currencies\n          currency_map\n          address\n          network\n          owners\n          threshold\n          pending\n        }\n        ... on DigitalAccount {\n          currencies\n          currency_map\n          account_id\n        }\n        ... on StripeAccount {\n          currencies\n          currency_map\n          account_id\n          publishable_key\n        }\n        ... on EthereumEscrowAccount {\n          currencies\n          currency_map\n          address\n          network\n          minimum_deposit_percent\n          host_refund_percent\n          refund_policies {\n            percent\n            timestamp\n          }\n        }\n        ... on EthereumRelayAccount {\n          currencies\n          currency_map\n          address\n          network\n          payment_splitter_contract\n        }\n        ... on EthereumStakeAccount {\n          currencies\n          currency_map\n          address\n          network\n          config_id\n          requirement_checkin_before\n        }\n      }\n      active\n      created_at\n      escrow {\n        minimum_amount\n        minimum_percent\n      }\n      fee\n      provider\n      relay {\n        payment_splitter_contract\n      }\n      title\n      type\n      user\n    }\n    subtotal\n    total\n  }\n}\n\nquery getMyTickets($event: MongoID!, $withPaymentInfo: Boolean) {\n  getMyTickets(event: $event, with_payment_info: $withPaymentInfo) {\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      assigned_to_expanded {\n        _id\n        name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      event\n      invited_by\n      type\n      type_expanded {\n        _id\n        title\n        prices {\n          cost\n          currency\n          default\n          payment_accounts\n          payment_accounts_expanded {\n            ...PaymentAccount\n          }\n        }\n      }\n      shortid\n      event_expanded {\n        _id\n        title\n      }\n    }\n    payments {\n      _id\n      state\n      amount\n      attempting_refund\n      currency\n      refund_info {\n        available_amount\n        refunded\n      }\n      refund_policy {\n        percent\n        requirements {\n          checkin_before\n        }\n        satisfy_all\n      }\n      refund_requirements_met\n      payment_account {\n        _id\n        account_info {\n          ... on EthereumStakeAccount {\n            currencies\n            currency_map\n            address\n            network\n            config_id\n            requirement_checkin_before\n          }\n        }\n        type\n      }\n    }\n  }\n}\n\nmutation redeemTickets($event: MongoID!, $items: [PurchasableItem!]!, $buyer_info: BuyerInfoInput, $inviter: MongoID, $user_info: UserInput, $connect_wallets: [ConnectWalletInput!], $buyer_wallet: String, $passcodes: [String!]) {\n  redeemTickets(\n    input: {event: $event, items: $items, buyer_info: $buyer_info, inviter: $inviter, user_info: $user_info, connect_wallets: $connect_wallets, buyer_wallet: $buyer_wallet, passcodes: $passcodes}\n  ) {\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    join_request {\n      _id\n      state\n    }\n  }\n}\n\nmutation AssignTickets($input: AssignTicketsInput!) {\n  assignTickets(input: $input)\n}\n\nmutation buyTickets($input: BuyTicketsInput!) {\n  buyTickets(input: $input) {\n    payment {\n      _id\n      failure_reason\n      state\n      stamps\n      transfer_metadata\n    }\n    join_request {\n      _id\n      state\n    }\n  }\n}\n\nmutation createEventTicketType($input: EventTicketTypeInput!) {\n  createEventTicketType(input: $input) {\n    _id\n    active\n    private\n    default\n    description\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    ticket_limit\n    title\n    limited\n    limited_whitelist_users {\n      _id\n      email\n    }\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nmutation deleteEventTicketType($event: MongoID!, $id: MongoID!) {\n  deleteEventTicketType(event: $event, _id: $id)\n}\n\nmutation updateEventTicketType($input: EventTicketTypeInput!, $id: MongoID!) {\n  updateEventTicketType(input: $input, _id: $id) {\n    _id\n    active\n    default\n    private\n    description\n    event\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    ticket_limit\n    title\n    offers {\n      _id\n      auto\n      broadcast_rooms\n      position\n      provider\n      provider_id\n      provider_network\n    }\n    limited\n    limited_whitelist_users {\n      _id\n      email\n    }\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nquery exportEventTickets($id: MongoID!, $ticketTypeIds: [MongoID!], $searchText: String, $pagination: PaginationInput, $checkedIn: Boolean) {\n  exportEventTickets(\n    _id: $id\n    ticket_type_ids: $ticketTypeIds\n    search_text: $searchText\n    pagination: $pagination\n    checked_in: $checkedIn\n  ) {\n    count\n    tickets {\n      _id\n      buyer_name\n      buyer_first_name\n      buyer_last_name\n      buyer_email\n      ticket_category\n      ticket_type\n      quantity\n      payment_amount\n      discount_amount\n      currency\n      discount_code\n      purchase_date\n      payment_provider\n      payment_id\n      checkin_date\n      is_assigned\n      assignee_email\n      assigned_to\n      assigned_email\n      is_issued\n      issued_by\n      is_claimed\n      active\n      cancelled_by\n      buyer_wallet\n      buyer_id\n      buyer_avatar\n      buyer_username\n      ticket_type_id\n      shortid\n    }\n  }\n}\n\nmutation CreateTickets($ticketType: MongoID!, $ticketAssignments: [TicketAssignment!]!) {\n  createTickets(ticket_type: $ticketType, ticket_assignments: $ticketAssignments) {\n    _id\n  }\n}\n\nquery CheckTicketTypePasscode($passcode: String!, $type: MongoID!) {\n  checkTicketTypePasscode(passcode: $passcode, type: $type)\n}": typeof types.CalculateTicketsPricingDocument,
    "query GetMe {\n  getMe {\n    ...User\n    email\n    email_verified\n    wallets_new\n    wallet_custodial\n    stripe_connected_account {\n      account_id\n      connected\n    }\n    kratos_wallet_address\n    kratos_farcaster_fid\n    kratos_unicorn_wallet_address\n    oauth2_allow_creation\n    oauth2_clients\n    oauth2_max_clients\n  }\n}\n\nmutation SetUserWallet($token: String!, $signature: String!) {\n  setUserWallet(token: $token, signature: $signature)\n}\n\nmutation UpdateUser($input: UserInput!) {\n  updateUser(input: $input) {\n    ...User\n  }\n}\n\nquery SearchUsers($query: String!) {\n  searchUsers(query: $query) {\n    _id\n    email\n    name\n    display_name\n    new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n    }\n  }\n}\n\nquery GetUser($id: MongoID, $username: String, $email: String, $lens_profile_id: String) {\n  getUser(\n    _id: $id\n    username: $username\n    email: $email\n    lens_profile_id: $lens_profile_id\n  ) {\n    _id\n    name\n    display_name\n    email\n    username\n    description\n    followers\n    following\n    hosted\n    addresses {\n      _id\n      street_1\n      street_2\n      city\n      region\n      postal\n      country\n      title\n      phone\n      longitude\n      latitude\n      additional_directions\n    }\n    new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n    }\n    cover_expanded {\n      _id\n      bucket\n      url\n      type\n      key\n    }\n    handle_facebook\n    handle_instagram\n    handle_linkedin\n    handle_twitter\n    handle_farcaster\n    handle_github\n    created_at\n  }\n}\n\nmutation deleteUser {\n  deleteUser\n}\n\nmutation syncUserUnicornWallet {\n  syncUserUnicornWallet\n}\n\nquery UsernameAvailability($wallet: String!, $username: String!) {\n  isUsernameAvailable(wallet: $wallet, username: $username)\n}": typeof types.GetMeDocument,
};
const documents: Documents = {
    "query GetEvent($id: MongoID, $shortid: String) {\n  getEvent(_id: $id, shortid: $shortid) {\n    _id\n    title\n    description\n    approval_required\n    start\n    end\n    shortid\n    host\n    cohosts\n    host_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    accepted\n    new_new_photos_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    address_directions\n    subevent_enabled\n    sessions {\n      _id\n      start\n      end\n      broadcast\n      description\n      title\n      broadcast\n      photos_expanded {\n        _id\n        key\n        bucket\n      }\n      speaker_users\n      speaker_users_expanded {\n        ...User\n      }\n    }\n    space\n    space_expanded {\n      _id\n      title\n      image_avatar\n      image_avatar_expanded {\n        _id\n        bucket\n        url\n        type\n        key\n      }\n    }\n    timezone\n    application_questions {\n      _id\n      question\n      required\n      position\n      type\n      options\n      select_type\n    }\n    application_profile_fields {\n      field\n      question\n      required\n    }\n    self_verification {\n      config {\n        date_of_birth\n        excludedCountries\n        expiry_date\n        gender\n        issuing_state\n        minimumAge\n        name\n        nationality\n        ofac\n        passport_number\n      }\n      enabled\n    }\n    rsvp_wallet_platforms {\n      platform\n      required\n    }\n    calendar_links {\n      google\n      ical\n      outlook\n      yahoo\n    }\n    offers {\n      _id\n      provider\n      provider_id\n      provider_network\n    }\n    event_ticket_types {\n      _id\n      title\n      offers {\n        _id\n        provider_network\n        provider_id\n        provider\n      }\n    }\n    guest_limit\n    guest_limit_per\n    terms_text\n    virtual\n    virtual_url\n    theme_data\n    url\n    url_go\n    external_url\n    external_hostname\n    published\n    private\n    payment_accounts_new\n    payment_accounts_expanded {\n      ...PaymentAccount\n    }\n    layout_sections {\n      id\n      hidden\n    }\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n    hide_attending\n    registration_disabled\n    ticket_limit_per\n  }\n}\n\nquery GetEvents($subeventParent: MongoID, $skip: Int = 0, $limit: Int = 100, $id: [MongoID!], $site: MongoID, $search: String, $accepted: MongoID, $highlight: Boolean, $unpublished: Boolean, $startFrom: DateTimeISO, $startTo: DateTimeISO, $endFrom: DateTimeISO, $hostFilter: HostFilter, $sort: EventSortInput) {\n  getEvents(\n    subevent_parent: $subeventParent\n    skip: $skip\n    limit: $limit\n    _id: $id\n    site: $site\n    search: $search\n    accepted: $accepted\n    highlight: $highlight\n    unpublished: $unpublished\n    start_from: $startFrom\n    start_to: $startTo\n    end_from: $endFrom\n    host_filter: $hostFilter\n    sort: $sort\n  ) {\n    _id\n    shortid\n    title\n    host\n    host_expanded_new {\n      _id\n      name\n      image_avatar\n    }\n    cohosts\n    cohosts_expanded_new {\n      _id\n      name\n      image_avatar\n    }\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      url\n      type\n    }\n    start\n    end\n    timezone\n    event_ticket_types {\n      _id\n      title\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n    }\n    broadcasts {\n      provider_id\n    }\n    address {\n      title\n      city\n      title\n      region\n      additional_directions\n    }\n    accepted\n    sessions {\n      _id\n      broadcast\n      description\n      end\n      speaker_users\n      speaker_users_expanded {\n        _id\n        name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      start\n      title\n    }\n    subevent_parent_expanded {\n      _id\n      shortid\n      title\n      slug\n      start\n      timezone\n      new_new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n        type\n        url\n      }\n      subevent_settings {\n        ticket_required_for_creation\n        ticket_required_for_purchase\n      }\n    }\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    guests\n  }\n}\n\nquery GetUpcomingEvents($user: MongoID!, $limit: Int = 100, $skip: Int = 0, $host: Boolean, $sort: JSON, $site: MongoID, $unpublished: Boolean) {\n  events: getUpcomingEvents(\n    user: $user\n    limit: $limit\n    skip: $skip\n    host: $host\n    sort: $sort\n    site: $site\n    unpublished: $unpublished\n  ) {\n    _id\n    shortid\n    title\n    slug\n    host\n    host_expanded_new {\n      _id\n      name\n      new_photos_expanded {\n        _id\n        key\n        bucket\n      }\n    }\n    cohosts\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      type\n      url\n    }\n    start\n    end\n    timezone\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    me_awaiting_approval\n    published\n    private\n    guests\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n  }\n}\n\nquery GetPastEvents($user: MongoID!, $limit: Int = 100, $skip: Int = 0, $sort: JSON, $site: MongoID, $host: Boolean, $unpublished: Boolean) {\n  events: getPastEvents(\n    user: $user\n    limit: $limit\n    skip: $skip\n    sort: $sort\n    site: $site\n    host: $host\n    unpublished: $unpublished\n  ) {\n    _id\n    shortid\n    title\n    slug\n    host\n    host_expanded_new {\n      _id\n      name\n      new_photos_expanded {\n        _id\n        key\n        bucket\n      }\n    }\n    cohosts\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      type\n      url\n    }\n    start\n    end\n    timezone\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    me_awaiting_approval\n    published\n    private\n    guests\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n  }\n}\n\nquery getEventInvitation($event: MongoID!) {\n  getEventInvitation(event: $event) {\n    _id\n    inviters\n  }\n}\n\nquery GetEventTicketTypes($input: GetEventTicketTypesInput!) {\n  getEventTicketTypes(input: $input) {\n    ticket_types {\n      _id\n      title\n      default\n      description\n      event\n      limited\n      limit\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n      whitelisted\n      photos_expanded(limit: 1) {\n        _id\n        key\n        type\n        bucket\n      }\n      category\n      category_expanded {\n        _id\n        description\n        title\n        position\n      }\n      position\n      passcode_enabled\n      recommended_upgrade_ticket_types\n    }\n  }\n}\n\nquery getMyEventJoinRequest($event: MongoID!) {\n  getMyEventJoinRequest(event: $event) {\n    _id\n    created_at\n    decided_at\n    decided_by\n    decided_by_expanded {\n      _id\n      display_name\n      image_avatar\n      username\n      wallets\n    }\n    state\n    payment {\n      _id\n      state\n    }\n    requested_tickets {\n      count\n      ticket_type\n    }\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nmutation acceptEvent($id: MongoID!, $email: String) {\n  acceptEvent(_id: $id, email: $email) {\n    state\n  }\n}\n\nmutation SubmitEventApplicationAnswers($answers: [EventApplicationAnswerInput!]!, $event: MongoID!, $email: String) {\n  submitEventApplicationAnswers(answers: $answers, event: $event, email: $email)\n}\n\nquery PeekEventGuests($id: MongoID!, $limit: Int) {\n  peekEventGuests(_id: $id, limit: $limit) {\n    items {\n      _id\n      image_avatar\n      name\n      display_name\n      first_name\n    }\n    total\n  }\n}\n\nmutation UpdateEventTheme($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    theme_data\n  }\n}\n\nquery GetEventCohostInvites($input: GetEventCohostRequestsInput!) {\n  getEventCohostInvites(input: $input) {\n    event\n    from_expanded {\n      _id\n      name\n    }\n  }\n}\n\nmutation DecideEventCohostRequest($input: DecideEventCohostRequestInput!) {\n  decideEventCohostRequest(input: $input)\n}\n\nmutation createEvent($input: EventInput!) {\n  createEvent(input: $input) {\n    _id\n    shortid\n  }\n}\n\nmutation PublishEvent($event: MongoID!) {\n  updateEvent(_id: $event, input: {published: true}) {\n    _id\n    published\n  }\n}\n\nmutation UpdateEventSettings($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    title\n    description\n    start\n    end\n    timezone\n    theme_data\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    longitude\n    latitude\n    virtual_url\n    registration_disabled\n    guest_limit\n    terms_text\n    terms_link\n    shortid\n    private\n    layout_sections {\n      id\n      hidden\n    }\n  }\n}\n\nmutation UpdateEventPhotos($id: MongoID!, $new_new_photos: [MongoID!]) {\n  updateEvent(_id: $id, input: {new_new_photos: $new_new_photos}) {\n    new_new_photos\n    new_new_photos_expanded(limit: 50) {\n      _id\n      key\n      bucket\n    }\n  }\n}\n\nmutation inviteEvent($event: MongoID!, $users: [MongoID!], $emails: [String!], $custom_body_html: String) {\n  inviteEvent(\n    input: {_id: $event, users: $users, emails: $emails, custom_body_html: $custom_body_html}\n  ) {\n    _id\n    invited\n  }\n}\n\nmutation AssignTickets($input: AssignTicketsInput!) {\n  assignTickets(input: $input)\n}\n\nquery GetEventTicketSales($event: MongoID!) {\n  getEventTicketSales(event: $event) {\n    sales {\n      amount\n      currency\n      decimals\n    }\n    last_update\n  }\n}\n\nquery listEventTicketTypes($event: MongoID!) {\n  listEventTicketTypes(event: $event) {\n    limited_whitelist_users {\n      _id\n      email\n    }\n    _id\n    active\n    address_required\n    default\n    description\n    description_line\n    event\n    external_ids\n    limited\n    offers {\n      _id\n      auto\n      broadcast_rooms\n      position\n      provider\n      provider_id\n      provider_network\n    }\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n      type\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    private\n    ticket_count\n    ticket_limit\n    title\n    ticket_limit_per\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nquery ListEventTokenGates($event: MongoID!, $ticketTypes: [MongoID!]) {\n  listEventTokenGates(event: $event, ticket_types: $ticketTypes) {\n    _id\n    decimals\n    event\n    gated_ticket_types\n    is_nft\n    max_value\n    min_value\n    name\n    network\n    token_address\n  }\n}\n\nmutation CreateEventTokenGate($input: EventTokenGateInput!) {\n  createEventTokenGate(input: $input) {\n    _id\n  }\n}\n\nmutation UpdateEventTokenGate($input: EventTokenGateInput!) {\n  updateEventTokenGate(input: $input) {\n    _id\n  }\n}\n\nmutation ManageEventCohostRequests($input: ManageEventCohostRequestsInput!) {\n  manageEventCohostRequests(input: $input)\n}\n\nquery GetEventInvitedStatistics($id: MongoID!, $statuses: [InvitationResponse!], $limit: Float) {\n  getEventInvitedStatistics(_id: $id, statuses: $statuses, limit: $limit) {\n    emails_opened\n    guests {\n      user\n      pending\n      joined\n      email\n      declined\n      user_expanded {\n        _id\n        display_name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n    }\n    total\n    total_declined\n    total_joined\n  }\n}\n\nquery GetEventGuestsStatistics($event: MongoID!) {\n  getEventGuestsStatistics(event: $event) {\n    going\n    pending_approval\n    pending_invite\n    declined\n    checked_in\n  }\n}\n\nmutation UpdateEventRegistrationForm($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    rsvp_wallet_platforms {\n      platform\n      required\n    }\n  }\n}\n\nquery ListEventGuests($ticketTypes: [MongoID!], $going: Boolean, $pendingApproval: Boolean, $pendingInvite: Boolean, $declined: Boolean, $checkedIn: Boolean, $sortBy: ListEventGuestsSortBy, $sortOrder: SortOrder, $event: MongoID!, $search: String, $limit: Int, $skip: Int) {\n  listEventGuests(\n    ticket_types: $ticketTypes\n    going: $going\n    pending_approval: $pendingApproval\n    pending_invite: $pendingInvite\n    declined: $declined\n    checked_in: $checkedIn\n    sort_by: $sortBy\n    sort_order: $sortOrder\n    event: $event\n    search: $search\n    limit: $limit\n    skip: $skip\n  ) {\n    items {\n      join_request {\n        _id\n        state\n        non_login_user {\n          _id\n          display_name\n          email\n          image_avatar\n          name\n        }\n        user_expanded {\n          _id\n          display_name\n          email\n          image_avatar\n          name\n        }\n        metadata\n      }\n      ticket {\n        _id\n        created_at\n        type_expanded {\n          _id\n          title\n        }\n        metadata\n      }\n      user {\n        _id\n        display_name\n        email\n        image_avatar\n        name\n      }\n    }\n    total\n  }\n}\n\nquery GetEventGuestDetailedInfo($event: MongoID!, $email: String) {\n  getEventGuestDetailedInfo(event: $event, email: $email) {\n    checkin_count\n    purchased_tickets {\n      _id\n      type_expanded {\n        _id\n        title\n      }\n    }\n    ticket {\n      _id\n      created_at\n      type\n      type_expanded {\n        _id\n        title\n      }\n    }\n    user {\n      _id\n      description\n      display_name\n      email\n      first_name\n      image_avatar\n      last_name\n      name\n    }\n    payments {\n      _id\n      account_expanded {\n        ...PaymentAccount\n      }\n      amount\n      currency\n      crypto_payment_info {\n        network\n        tx_hash\n      }\n      stripe_payment_info {\n        card {\n          brand\n          last4\n        }\n        payment_intent\n      }\n      transfer_params\n      formatted_total_amount\n    }\n    join_request {\n      _id\n      state\n    }\n    application {\n      answer\n      answers\n      question\n    }\n  }\n}\n\nmutation submitEventApplicationQuestions($event: MongoID!, $questions: [QuestionInput!]!) {\n  submitEventApplicationQuestions(event: $event, questions: $questions) {\n    _id\n    question\n    required\n    position\n    type\n    options\n    select_type\n  }\n}\n\nmutation updateEventApplicationProfiles($fields: [ApplicationProfileFieldInput!], $id: MongoID!) {\n  updateEvent(input: {application_profile_fields: $fields}, _id: $id) {\n    application_profile_fields {\n      field\n      required\n      question\n    }\n  }\n}\n\nmutation decideUserJoinRequests($decision: EventJoinRequestState!, $event: MongoID!, $requests: [MongoID!]!) {\n  decideUserJoinRequests(\n    input: {decision: $decision, event: $event, requests: $requests}\n  ) {\n    _id\n    processed\n  }\n}\n\nquery getEventJoinRequests($event: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getEventJoinRequests(event: $event, skip: $skip, limit: $limit, state: $state) {\n    total\n    records {\n      _id\n      state\n      created_at\n      email\n      user\n      user_expanded {\n        _id\n        name\n        display_name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      non_login_user {\n        _id\n        name\n        email\n        display_name\n        username\n      }\n    }\n  }\n}\n\nquery GetListEventEmailSettings($event: MongoID!, $system: Boolean, $sent: Boolean, $scheduled: Boolean) {\n  listEventEmailSettings(\n    event: $event\n    system: $system\n    sent: $sent\n    scheduled: $scheduled\n  ) {\n    body_preview\n    _id\n    disabled\n    is_system_email\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    owner_expanded {\n      _id\n      image_avatar\n      new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n      }\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    scheduled_at\n    sent_at\n    subject_preview\n    type\n    custom_body_html\n    custom_subject_html\n    opened {\n      email\n      stamp\n    }\n  }\n}\n\nmutation UpdateEventEmailSetting($input: UpdateEventEmailSettingInput!) {\n  updateEventEmailSetting(input: $input) {\n    _id\n    body_preview\n    is_system_email\n    disabled\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    owner_expanded {\n      image_avatar\n    }\n    scheduled_at\n    sent_at\n    subject_preview\n    type\n    custom_body_html\n    custom_subject_html\n    template\n  }\n}\n\nmutation CreateEventEmailSetting($input: CreateEventEmailSettingInput!) {\n  createEventEmailSetting(input: $input) {\n    _id\n    body_preview\n    cc\n    custom_body_html\n    context\n    custom_subject_html\n    disabled\n    is_system_email\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    owner_expanded {\n      image_avatar\n    }\n    scheduled_at\n    sendgrid_template_id\n    sent_at\n    subject_preview\n    template\n    type\n    opened {\n      email\n      stamp\n    }\n  }\n}\n\nmutation DeleteEventEmailSetting($id: MongoID!) {\n  deleteEventEmailSetting(_id: $id)\n}\n\nmutation SendEventEmailSettingTestEmails($input: SendEventEmailSettingTestEmailsInput!) {\n  sendEventEmailSettingTestEmails(input: $input)\n}\n\nmutation ToggleEventEmailSettings($disabled: Boolean!, $ids: [MongoID!]!, $event: MongoID!) {\n  toggleEventEmailSettings(disabled: $disabled, ids: $ids, event: $event)\n}\n\nmutation UpdateEventToggleAttending($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    hide_attending\n  }\n}\n\nquery GetTickets($event: MongoID, $user: MongoID, $ticket_types: [MongoID!], $email: String) {\n  getTickets(\n    event: $event\n    user: $user\n    ticket_types: $ticket_types\n    email: $email\n  ) {\n    _id\n    accepted\n    assigned_email\n    assigned_to\n    assigned_to_expanded {\n      _id\n      name\n      new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n      }\n    }\n    event\n    invited_by\n    type\n    shortid\n  }\n}\n\nmutation CreatePoapDrop($input: CreatePoapInput!) {\n  createPoapDrop(input: $input) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nquery ListPoapDrops($event: MongoID!) {\n  listPoapDrops(event: $event) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n    minting_network\n  }\n}\n\nquery ListMyPoapClaims($event: MongoID) {\n  listMyPoapClaims(event: $event) {\n    drop {\n      _id\n    }\n    claimed_date\n  }\n}\n\nquery getEventCheckInState($id: MongoID) {\n  getEvent(_id: $id) {\n    checkedin\n  }\n}\n\nmutation ClaimPoap($wallet: String!, $drop: MongoID!) {\n  claimPoap(wallet: $wallet, drop: $drop)\n}\n\nmutation UpdatePoapDrop($input: UpdatePoapInput!, $drop: MongoID!) {\n  updatePoapDrop(input: $input, drop: $drop) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nquery GetPoapDropInfoById($getPoapDropInfoByIdId: Float!) {\n  getPoapDropInfoById(id: $getPoapDropInfoByIdId) {\n    description\n    image_url\n    name\n  }\n}\n\nquery CheckPoapDropEditCode($code: String!, $checkPoapDropEditCodeId: Int!) {\n  checkPoapDropEditCode(code: $code, id: $checkPoapDropEditCodeId)\n}\n\nmutation ImportPoapDrop($input: ImportPoapInput!, $code: String!, $importPoapDropId: Float!) {\n  importPoapDrop(input: $input, code: $code, id: $importPoapDropId) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nmutation CancelEvent($event: MongoID!) {\n  cancelEvent(_id: $event) {\n    _id\n  }\n}\n\nmutation cloneEvent($input: CloneEventInput!) {\n  cloneEvent(input: $input)\n}\n\nquery GenerateRecurringDates($input: GenerateRecurringDatesInput!) {\n  generateRecurringDates(input: $input)\n}\n\nmutation CreateEventTicketDiscounts($event: MongoID!, $inputs: [EventPaymentTicketDiscountInput!]!) {\n  createEventTicketDiscounts(event: $event, inputs: $inputs) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation UpdateEventTicketDiscount($event: MongoID!, $input: UpdateEventTicketDiscountInput!) {\n  updateEventTicketDiscount(event: $event, input: $input) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation DeleteEventTicketDiscounts($event: MongoID!, $discounts: [String!]!) {\n  deleteEventTicketDiscounts(event: $event, discounts: $discounts) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation UpdateEventSelfVerification($id: MongoID!, $self_verification: SelfVerificationInput) {\n  updateEvent(_id: $id, input: {self_verification: $self_verification}) {\n    self_verification {\n      config {\n        date_of_birth\n        excludedCountries\n        expiry_date\n        gender\n        issuing_state\n        minimumAge\n        name\n        nationality\n        ofac\n        passport_number\n      }\n      enabled\n    }\n  }\n}\n\nquery GetEventPaymentStatistics($event: MongoID!) {\n  getEventPaymentStatistics(event: $event) {\n    total_payments\n    stripe_payments {\n      count\n      revenue {\n        currency\n        formatted_total_amount\n      }\n    }\n    crypto_payments {\n      count\n      revenue {\n        currency\n        formatted_total_amount\n      }\n      networks {\n        chain_id\n        count\n      }\n    }\n  }\n}\n\nquery GetListEventPayments($skip: Int, $limit: Int, $event: MongoID!, $provider: NewPaymentProvider, $networks: [String!], $checked_in: Boolean, $ticket_types: [MongoID!], $search: String) {\n  listEventPayments(\n    skip: $skip\n    limit: $limit\n    event: $event\n    provider: $provider\n    networks: $networks\n    checked_in: $checked_in\n    ticket_types: $ticket_types\n    search: $search\n  ) {\n    records {\n      _id\n      account_expanded {\n        provider\n      }\n      stripe_payment_info {\n        payment_intent\n        card {\n          last4\n          brand\n        }\n      }\n      application {\n        question\n        answer\n      }\n      buyer_info {\n        email\n        name\n      }\n      buyer_user {\n        email\n        display_name\n        name\n        image_avatar\n      }\n      amount\n      currency\n      due_amount\n      fee\n      formatted_total_amount\n      formatted_discount_amount\n      currency\n      user\n      stamps\n      ticket_types_expanded {\n        _id\n        category_expanded {\n          title\n        }\n      }\n      state\n      account_expanded {\n        _id\n        active\n        created_at\n        user\n        type\n        title\n        provider\n      }\n      ref_data\n      transfer_params\n      transfer_metadata\n      crypto_payment_info {\n        network\n        tx_hash\n      }\n    }\n    total\n  }\n}\n\nquery getTicketStatistics($id: MongoID!) {\n  getTicketStatistics(id: $id) {\n    all\n    checked_in\n    invited\n    issued\n    cancelled\n    applicants {\n      state\n      count\n    }\n    not_checked_in\n    ticket_types {\n      ticket_type\n      ticket_type_title\n      count\n    }\n  }\n}": types.GetEventDocument,
    "query GetSystemFiles($categories: [FileCategory!]) {\n  getSystemFiles(categories: $categories) {\n    _id\n    name\n    category\n    url\n    type\n    bucket\n    key\n  }\n}\n\nmutation createFileUploads($uploadInfos: [FileUploadInfo!]!, $directory: String!) {\n  createFileUploads(upload_infos: $uploadInfos, directory: $directory) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    presignedUrl: presigned_url\n  }\n}\n\nmutation confirmFileUploads($ids: [MongoID!]!) {\n  confirmFileUploads(ids: $ids)\n}\n\nmutation updateFileDescriptionMutation($input: FileInput!, $id: MongoID!) {\n  updateFile(input: $input, _id: $id) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    description\n  }\n}": types.GetSystemFilesDocument,
    "fragment User on User {\n  _id\n  name\n  display_name\n  first_name\n  last_name\n  username\n  description\n  job_title\n  company_name\n  addresses {\n    _id\n    street_1\n    street_2\n    city\n    region\n    postal\n    country\n    title\n    phone\n    longitude\n    latitude\n    additional_directions\n  }\n  icebreakers {\n    _id\n    value\n    question_expanded {\n      _id\n      title\n    }\n  }\n  handle_facebook\n  handle_instagram\n  handle_linkedin\n  handle_twitter\n  handle_farcaster\n  handle_github\n  pronoun\n  calendly_url\n  website\n  new_photos_expanded(limit: 1) {\n    _id\n    key\n    bucket\n  }\n  url\n  url_go\n  lens_profile_synced\n  followers\n  following\n  hosted\n}\n\nfragment PaymentAccount on NewPaymentAccount {\n  _id\n  provider\n  type\n  title\n  account_info {\n    ... on EthereumAccount {\n      currencies\n      currency_map\n      address\n      network\n    }\n    ... on SafeAccount {\n      currencies\n      currency_map\n      address\n      network\n      owners\n      threshold\n      pending\n    }\n    ... on DigitalAccount {\n      currencies\n      currency_map\n      account_id\n    }\n    ... on StripeAccount {\n      currencies\n      currency_map\n      account_id\n      publishable_key\n    }\n    ... on EthereumEscrowAccount {\n      currencies\n      currency_map\n      address\n      network\n      minimum_deposit_percent\n      host_refund_percent\n      refund_policies {\n        percent\n        timestamp\n      }\n    }\n    ... on EthereumRelayAccount {\n      currencies\n      currency_map\n      address\n      network\n      payment_splitter_contract\n    }\n    ... on EthereumStakeAccount {\n      currencies\n      currency_map\n      address\n      network\n      config_id\n      requirement_checkin_before\n    }\n    ... on SolanaAccount {\n      currencies\n      currency_map\n      address\n      network\n    }\n  }\n}\n\nfragment AccountInfoFragment on AccountInfo {\n  ... on EthereumAccount {\n    currencies\n    currency_map\n    address\n    network\n  }\n  ... on SafeAccount {\n    currencies\n    currency_map\n    address\n    network\n    owners\n    threshold\n    pending\n  }\n  ... on DigitalAccount {\n    currencies\n    currency_map\n    account_id\n  }\n  ... on StripeAccount {\n    currencies\n    currency_map\n    account_id\n    publishable_key\n  }\n  ... on EthereumEscrowAccount {\n    currencies\n    currency_map\n    address\n    network\n    minimum_deposit_percent\n    host_refund_percent\n    refund_policies {\n      percent\n      timestamp\n    }\n  }\n  ... on EthereumRelayAccount {\n    currencies\n    currency_map\n    address\n    network\n    payment_splitter_contract\n  }\n  ... on EthereumStakeAccount {\n    currencies\n    currency_map\n    address\n    network\n    config_id\n    requirement_checkin_before\n  }\n  ... on SolanaAccount {\n    currencies\n    currency_map\n    address\n    network\n  }\n}": types.UserFragmentDoc,
    "query ListLaunchpadGroups($address: String, $search: String) {\n  listLaunchpadGroups(address: $address, search: $search) {\n    items {\n      address\n      cover_photo\n      cover_photo_expanded {\n        _id\n        key\n        bucket\n      }\n      cover_photo_url\n      implementation_address\n      name\n    }\n  }\n}\n\nmutation AddLaunchpadCoin($input: LaunchpadCoinInput!) {\n  addLaunchpadCoin(input: $input) {\n    address\n  }\n}\n\nmutation AddLaunchpadGroup($input: AddLaunchpadGroupInput!) {\n  addLaunchpadGroup(input: $input) {\n    address\n  }\n}\n\nquery Items($skip: Int, $limit: Int, $address: String) {\n  listLaunchpadCoins(skip: $skip, limit: $limit, address: $address) {\n    items {\n      handle_telegram\n      handle_discord\n      handle_farcaster\n      handle_twitter\n      address\n      owner\n      website\n    }\n  }\n}": types.ListLaunchpadGroupsDocument,
    "query GetListLemonheadSponsors($wallet: String!) {\n  listLemonheadSponsors(wallet: $wallet) {\n    sponsors {\n      limit\n      sponsor {\n        _id\n        name\n        image_url\n        message\n      }\n      remaining\n    }\n  }\n}\n\nquery CanMintLemonhead($wallet: String!) {\n  canMintLemonhead(wallet: $wallet) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}\n\nquery CanMintPassport($wallet: String!, $provider: PassportProvider!) {\n  canMintPassport(wallet: $wallet, provider: $provider) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}\n\nquery GetListMyLemonheadInvitations {\n  listMyLemonheadInvitations {\n    invitations {\n      invitee_wallet\n      minted_at\n      user {\n        _id\n        username\n        image_avatar\n      }\n    }\n  }\n}\n\nquery GetMyLemonheadInvitationRank {\n  getMyLemonheadInvitationRank {\n    rank\n    user {\n      _id\n      name\n      display_name\n      username\n      image_avatar\n      lemonhead_inviter_wallet\n      kratos_wallet_address\n    }\n    invitations_count\n  }\n}\n\nquery GetLemonheadInvitationRank($skip: Int!, $limit: Int!) {\n  getLemonheadInvitationRank(skip: $skip, limit: $limit) {\n    items {\n      rank\n      user {\n        _id\n        name\n        display_name\n        username\n        image_avatar\n        lemonhead_inviter_wallet\n        kratos_wallet_address\n      }\n      invitations_count\n    }\n    total\n  }\n}\n\nmutation SetUserWallet($token: String!, $signature: String!) {\n  setUserWallet(token: $token, signature: $signature)\n}\n\nmutation UpdateMyLemonheadInvitations($invitations: [String!]!) {\n  updateMyLemonheadInvitations(invitations: $invitations) {\n    success\n    message\n    wallets\n  }\n}": types.GetListLemonheadSponsorsDocument,
    "query listChains {\n  listChains {\n    active\n    platform\n    chain_id\n    name\n    code_name\n    rpc_url\n    block_explorer_url\n    block_explorer_name\n    block_explorer_for_tx\n    block_explorer_for_token\n    block_explorer_for_address\n    block_explorer_icon_url\n    block_time\n    safe_confirmations\n    logo_url\n    tokens {\n      active\n      name\n      symbol\n      decimals\n      contract\n      logo_url\n      is_native\n    }\n    access_registry_contract\n    poap_contract\n    marketplace_contract\n    marketplace_version\n    biconomy_api_key\n    ens_registry\n    proxy_admin_contract\n    payment_config_registry_contract\n    escrow_manager_contract\n    relay_payment_contract\n    stake_payment_contract\n    reward_registry_contract\n    eas_event_contract\n    eas_graphql_url\n    aragon_network\n    axelar_chain_name\n    donation_registry_contract\n    lemonhead_contract_address\n    lemonade_passport_contract_address\n    zugrama_passport_contract_address\n    vinyl_nation_passport_contract_address\n    drip_nation_passport_contract_address\n    festival_nation_passport_contract_address\n    lemonade_username_contract_address\n    poap_enabled\n    launchpad_closed_permissions_contract_address\n    launchpad_treasury_address_fee_split_manager_implementation_contract_address\n    launchpad_treasury_staking_manager_implementation_contract_address\n    launchpad_zap_contract_address\n    launchpad_fee_escrow_contract_address\n    launchpad_market_capped_price_contract_address\n    launchpad_market_utils_contract_address\n  }\n}\n\nquery GetUserWalletRequest($wallet: String!) {\n  getUserWalletRequest(wallet: $wallet) {\n    message\n    token\n  }\n}\n\nmutation createFileUploads($uploadInfos: [FileUploadInfo!]!, $directory: String!) {\n  createFileUploads(upload_infos: $uploadInfos, directory: $directory) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    presignedUrl: presigned_url\n  }\n}\n\nquery GetSelfVerificationStatus($config: SelfVerificationConfigInput!) {\n  getSelfVerificationStatus(config: $config) {\n    disclosures {\n      type\n      verified\n    }\n  }\n}\n\nmutation CreateSelfVerificationRequest($config: SelfVerificationConfigInput!) {\n  createSelfVerificationRequest(config: $config) {\n    endpoint\n    endpoint_type\n    scope\n    uuid\n  }\n}": types.ListChainsDocument,
    "mutation CreateOauth2Client($input: Oauth2ClientInput!) {\n  createOauth2Client(input: $input) {\n    client_id\n    client_secret\n    audience\n  }\n}": types.CreateOauth2ClientDocument,
    "query CanMintPassport($wallet: String!, $provider: PassportProvider!) {\n  canMintPassport(wallet: $wallet, provider: $provider) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}": types.CanMintPassportDocument,
    "mutation createStripeCard($paymentMethod: String!) {\n  createStripeCard(payment_method: $paymentMethod) {\n    _id\n    provider_id\n  }\n}\n\nquery getStripeCards {\n  getStripeCards {\n    _id\n    active\n    brand\n    last4\n    name\n    provider_id\n    stamp\n    user\n  }\n}\n\nmutation updatePayment($input: UpdatePaymentInput!) {\n  updatePayment(input: $input) {\n    _id\n    transfer_metadata\n    state\n    failure_reason\n  }\n}\n\nquery getNewPayment($id: MongoID!, $paymentSecret: String) {\n  getNewPayment(_id: $id, payment_secret: $paymentSecret) {\n    _id\n    due_amount\n    amount\n    currency\n    ref_data\n    state\n    failure_reason\n    account_expanded {\n      _id\n      type\n      account_info {\n        ... on EthereumEscrowAccount {\n          currencies\n          currency_map\n          address\n          network\n          minimum_deposit_percent\n          host_refund_percent\n          refund_policies {\n            percent\n            timestamp\n          }\n        }\n      }\n    }\n  }\n}\n\nquery getPaymentRefundSignature($id: MongoID!) {\n  getPaymentRefundSignature(_id: $id) {\n    args\n    signature\n  }\n}\n\nmutation CancelPayment($input: CancelPaymentInput!) {\n  cancelPayment(input: $input)\n}\n\nmutation GenerateStripeAccountLink($refreshUrl: String!, $returnUrl: String!) {\n  generateStripeAccountLink(refresh_url: $refreshUrl, return_url: $returnUrl) {\n    url\n  }\n}\n\nquery listNewPaymentAccounts($id: [MongoID!], $type: PaymentAccountType, $provider: NewPaymentProvider) {\n  listNewPaymentAccounts(_id: $id, type: $type, provider: $provider) {\n    _id\n    account_info {\n      ...AccountInfoFragment\n    }\n    active\n    provider\n    created_at\n    type\n    user\n    title\n  }\n}\n\nmutation createNewPaymentAccount($type: PaymentAccountType!, $provider: NewPaymentProvider, $account_info: JSON) {\n  createNewPaymentAccount(\n    input: {type: $type, provider: $provider, account_info: $account_info}\n  ) {\n    _id\n    account_info {\n      ...AccountInfoFragment\n    }\n    active\n    provider\n    created_at\n    type\n    user\n    title\n  }\n}\n\nmutation updateEventPaymentAccounts($id: MongoID!, $payment_accounts_new: [MongoID!]) {\n  updateEvent(_id: $id, input: {payment_accounts_new: $payment_accounts_new}) {\n    payment_accounts_new\n    payment_accounts_expanded {\n      ...PaymentAccount\n    }\n  }\n}": types.CreateStripeCardDocument,
    "fragment Space on Space {\n  _id\n  title\n  admins {\n    _id\n    image_avatar\n  }\n  description\n  is_ambassador\n  followed\n  followers\n  followers_count\n  image_avatar\n  image_avatar_expanded {\n    _id\n    bucket\n    url\n    type\n    key\n  }\n  image_cover\n  image_cover_expanded {\n    _id\n    bucket\n    url\n    type\n    key\n  }\n  creator\n  creator_expanded {\n    _id\n    name\n    image_avatar\n  }\n  slug\n  private\n  listed_events\n  website\n  address {\n    _id\n    city\n    country\n    latitude\n    longitude\n    street_1\n    street_2\n    region\n    title\n  }\n  handle_instagram\n  handle_twitter\n  handle_linkedin\n  handle_youtube\n  handle_tiktok\n  personal\n  theme_data\n  sub_spaces\n  lens_feed_id\n  council_members {\n    user {\n      _id\n      display_name\n      username\n      image_avatar\n    }\n    wallet\n  }\n  state\n}\n\nfragment SpaceTagFragment on SpaceTag {\n  _id\n  color\n  space\n  tag\n  targets\n  type\n}\n\nfragment SpaceEventRequestFragment on SpaceEventRequest {\n  _id\n  created_at\n  space\n  event\n  state\n  decided_at\n  decided_by\n}\n\nquery GetSpaces($with_my_spaces: Boolean, $with_public_spaces: Boolean, $roles: [SpaceRole!], $featured: Boolean) {\n  listSpaces(\n    with_my_spaces: $with_my_spaces\n    with_public_spaces: $with_public_spaces\n    roles: $roles\n    featured: $featured\n  ) {\n    ...Space\n  }\n}\n\nquery GetSpace($id: MongoID, $slug: String, $hostname: String) {\n  getSpace(_id: $id, slug: $slug, hostname: $hostname) {\n    ...Space\n  }\n}\n\nquery GetSpaceEvents($skip: Int, $limit: Int, $startFrom: DateTimeISO, $startTo: DateTimeISO, $space: MongoID, $sort: EventSortInput, $endFrom: DateTimeISO, $endTo: DateTimeISO, $spaceTags: [MongoID!]) {\n  getEvents(\n    skip: $skip\n    limit: $limit\n    start_from: $startFrom\n    start_to: $startTo\n    space: $space\n    sort: $sort\n    end_from: $endFrom\n    end_to: $endTo\n    space_tags: $spaceTags\n  ) {\n    _id\n    shortid\n    title\n    host_expanded_new {\n      _id\n      image_avatar\n      name\n    }\n    visible_cohosts_expanded_new {\n      _id\n      image_avatar\n      name\n    }\n    address {\n      city\n      country\n      region\n      latitude\n      longitude\n    }\n    new_new_photos_expanded {\n      _id\n      bucket\n      key\n      type\n      url\n    }\n    published\n    start\n    end\n    timezone\n    external_url\n    external_hostname\n    event_ticket_types {\n      _id\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n    }\n    host_expanded_new {\n      _id\n      image_avatar\n    }\n    visible_cohosts_expanded_new {\n      _id\n      image_avatar\n    }\n  }\n}\n\nquery GetSpaceEventsCalendar($space: MongoID) {\n  getEvents(space: $space) {\n    _id\n    start\n    address {\n      _id\n      latitude\n      longitude\n    }\n  }\n}\n\nquery GetSpaceTags($space: MongoID!) {\n  listSpaceTags(space: $space) {\n    ...SpaceTagFragment\n  }\n}\n\nquery GetSpaceEventRequests($space: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getSpaceEventRequests(space: $space, skip: $skip, limit: $limit, state: $state) {\n    records {\n      _id\n      created_at\n      space\n      event\n      state\n      decided_at\n      decided_by\n      created_by_expanded {\n        name\n        display_name\n        email\n      }\n      event_expanded {\n        title\n        start\n        timezone\n        address {\n          city\n          country\n          region\n        }\n        new_new_photos_expanded {\n          _id\n          bucket\n          key\n          type\n          url\n        }\n        guests\n      }\n    }\n    total\n  }\n}\n\nquery GetMySpaceEventRequests($space: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getMySpaceEventRequests(\n    space: $space\n    skip: $skip\n    limit: $limit\n    state: $state\n  ) {\n    records {\n      _id\n      state\n      event_expanded {\n        _id\n        title\n        new_new_photos_expanded {\n          key\n          bucket\n          _id\n          url\n          type\n        }\n      }\n    }\n  }\n}\n\nquery getSubSpaces($id: MongoID!) {\n  getSubSpaces(_id: $id) {\n    _id\n    title\n    description\n    followers_count\n    slug\n    is_admin\n    followed\n    image_avatar_expanded {\n      _id\n      bucket\n      url\n      type\n      key\n    }\n  }\n}\n\nquery GetListSpaceCategories {\n  listSpaceCategories {\n    description\n    image_url\n    listed_events_count\n    space\n    title\n  }\n}\n\nquery GetListGeoRegions {\n  listGeoRegions {\n    _id\n    title\n    cities {\n      name\n      region\n      space\n      icon_url\n      listed_events_count\n    }\n  }\n}\n\nquery CheckSpaceSlug($slug: String!) {\n  canUseSpaceSlug(slug: $slug)\n}\n\nquery SearchSpaces($skip: Int, $limit: Int, $input: SearchSpaceInput) {\n  searchSpaces(input: $input, limit: $limit, skip: $skip) {\n    items {\n      ...Space\n    }\n    total\n  }\n}\n\nquery GetSpaceMembers($space: MongoID!, $roles: [SpaceRole!], $state: SpaceMembershipState, $visible: Boolean, $skip: Int, $limit: Int, $search: String, $sort: SortInput, $deletion: Boolean, $tags: [MongoID!]) {\n  listSpaceMembers(\n    space: $space\n    roles: $roles\n    state: $state\n    visible: $visible\n    skip: $skip\n    limit: $limit\n    search: $search\n    sort: $sort\n    deletion: $deletion\n    tags: $tags\n  ) {\n    total\n    items {\n      _id\n      user\n      user_name\n      email\n      space\n      role\n      state\n      visible\n      role_changed_at\n      deleted_at\n      user_expanded {\n        _id\n        name\n        display_name\n        email\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      event_count\n      checkin_count\n      tags {\n        _id\n        space\n        tag\n        color\n        type\n        targets\n        targets_count\n      }\n    }\n  }\n}\n\nmutation FollowSpace($space: MongoID!) {\n  followSpace(space: $space)\n}\n\nmutation UnfollowSpace($space: MongoID!) {\n  unfollowSpace(space: $space)\n}\n\nmutation UpdateSpace($id: MongoID!, $input: SpaceInput!) {\n  updateSpace(_id: $id, input: $input) {\n    ...Space\n  }\n}\n\nmutation PinEventsToSpace($space: MongoID!, $events: [MongoID!]!, $tags: [MongoID!]) {\n  pinEventsToSpace(space: $space, events: $events, tags: $tags) {\n    requests {\n      ...SpaceEventRequestFragment\n    }\n  }\n}\n\nmutation CreateExternalEvent($input: EventInput!) {\n  createEvent(input: $input) {\n    _id\n  }\n}\n\nmutation CreateSpace($input: SpaceInput!) {\n  createSpace(input: $input) {\n    ...Space\n  }\n}\n\nmutation DecideSpaceEventRequests($input: DecideSpaceEventRequestsInput!) {\n  decideSpaceEventRequests(input: $input)\n}\n\nmutation AddSpaceMembers($input: AddSpaceMemberInput!) {\n  addSpaceMembers(input: $input)\n}\n\nmutation DeleteSpaceMembers($input: DeleteSpaceMemberInput!) {\n  deleteSpaceMembers(input: $input) {\n    _id\n    role\n    state\n    user\n    user_name\n    email\n    deleted_at\n    role_changed_at\n    user_expanded {\n      _id\n      name\n      email\n      image_avatar\n    }\n    visible\n  }\n}\n\nmutation DeleteSpace($id: MongoID!) {\n  deleteSpace(_id: $id)\n}\n\nmutation UpsertSpaceTag($input: SpaceTagInput!) {\n  insertSpaceTag(input: $input) {\n    ...SpaceTagFragment\n  }\n}\n\nmutation ManageSpaceTag($tagged: Boolean!, $target: String!, $id: MongoID!, $space: MongoID!) {\n  manageSpaceTag(tagged: $tagged, target: $target, _id: $id, space: $space)\n}\n\nmutation DeleteSpaceTag($id: MongoID!, $space: MongoID!) {\n  deleteSpaceTag(_id: $id, space: $space)\n}\n\nmutation AttachSubSpaces($id: MongoID!, $subSpaces: [String!]!) {\n  attachSubSpaces(_id: $id, sub_spaces: $subSpaces)\n}\n\nmutation RemoveSubSpaces($subSpaces: [MongoID!]!, $id: MongoID!) {\n  removeSubSpaces(sub_spaces: $subSpaces, _id: $id)\n}\n\nmutation UpdateSubSpaceOrder($id: MongoID!, $subSpaces: [MongoID!]!) {\n  updateSubSpaceOrder(_id: $id, sub_spaces: $subSpaces)\n}\n\nmutation UpsertSpaceTag($input: SpaceTagInput!) {\n  insertSpaceTag(input: $input) {\n    ...SpaceTagFragment\n  }\n}\n\nmutation DeleteSpaceTag($id: MongoID!, $space: MongoID!) {\n  deleteSpaceTag(_id: $id, space: $space)\n}": types.SpaceFragmentDoc,
    "query CalculateTicketsPricing($input: CalculateTicketsPricingInput!) {\n  calculateTicketsPricing(input: $input) {\n    deposit_infos {\n      minimum_amount\n      minimum_percent\n    }\n    discount\n    payment_accounts {\n      _id\n      account_info {\n        ... on SolanaAccount {\n          currencies\n          currency_map\n          address\n          network\n        }\n        ... on EthereumAccount {\n          currencies\n          currency_map\n          address\n          network\n        }\n        ... on SafeAccount {\n          currencies\n          currency_map\n          address\n          network\n          owners\n          threshold\n          pending\n        }\n        ... on DigitalAccount {\n          currencies\n          currency_map\n          account_id\n        }\n        ... on StripeAccount {\n          currencies\n          currency_map\n          account_id\n          publishable_key\n        }\n        ... on EthereumEscrowAccount {\n          currencies\n          currency_map\n          address\n          network\n          minimum_deposit_percent\n          host_refund_percent\n          refund_policies {\n            percent\n            timestamp\n          }\n        }\n        ... on EthereumRelayAccount {\n          currencies\n          currency_map\n          address\n          network\n          payment_splitter_contract\n        }\n        ... on EthereumStakeAccount {\n          currencies\n          currency_map\n          address\n          network\n          config_id\n          requirement_checkin_before\n        }\n      }\n      active\n      created_at\n      escrow {\n        minimum_amount\n        minimum_percent\n      }\n      fee\n      provider\n      relay {\n        payment_splitter_contract\n      }\n      title\n      type\n      user\n    }\n    subtotal\n    total\n  }\n}\n\nquery getMyTickets($event: MongoID!, $withPaymentInfo: Boolean) {\n  getMyTickets(event: $event, with_payment_info: $withPaymentInfo) {\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      assigned_to_expanded {\n        _id\n        name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      event\n      invited_by\n      type\n      type_expanded {\n        _id\n        title\n        prices {\n          cost\n          currency\n          default\n          payment_accounts\n          payment_accounts_expanded {\n            ...PaymentAccount\n          }\n        }\n      }\n      shortid\n      event_expanded {\n        _id\n        title\n      }\n    }\n    payments {\n      _id\n      state\n      amount\n      attempting_refund\n      currency\n      refund_info {\n        available_amount\n        refunded\n      }\n      refund_policy {\n        percent\n        requirements {\n          checkin_before\n        }\n        satisfy_all\n      }\n      refund_requirements_met\n      payment_account {\n        _id\n        account_info {\n          ... on EthereumStakeAccount {\n            currencies\n            currency_map\n            address\n            network\n            config_id\n            requirement_checkin_before\n          }\n        }\n        type\n      }\n    }\n  }\n}\n\nmutation redeemTickets($event: MongoID!, $items: [PurchasableItem!]!, $buyer_info: BuyerInfoInput, $inviter: MongoID, $user_info: UserInput, $connect_wallets: [ConnectWalletInput!], $buyer_wallet: String, $passcodes: [String!]) {\n  redeemTickets(\n    input: {event: $event, items: $items, buyer_info: $buyer_info, inviter: $inviter, user_info: $user_info, connect_wallets: $connect_wallets, buyer_wallet: $buyer_wallet, passcodes: $passcodes}\n  ) {\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    join_request {\n      _id\n      state\n    }\n  }\n}\n\nmutation AssignTickets($input: AssignTicketsInput!) {\n  assignTickets(input: $input)\n}\n\nmutation buyTickets($input: BuyTicketsInput!) {\n  buyTickets(input: $input) {\n    payment {\n      _id\n      failure_reason\n      state\n      stamps\n      transfer_metadata\n    }\n    join_request {\n      _id\n      state\n    }\n  }\n}\n\nmutation createEventTicketType($input: EventTicketTypeInput!) {\n  createEventTicketType(input: $input) {\n    _id\n    active\n    private\n    default\n    description\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    ticket_limit\n    title\n    limited\n    limited_whitelist_users {\n      _id\n      email\n    }\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nmutation deleteEventTicketType($event: MongoID!, $id: MongoID!) {\n  deleteEventTicketType(event: $event, _id: $id)\n}\n\nmutation updateEventTicketType($input: EventTicketTypeInput!, $id: MongoID!) {\n  updateEventTicketType(input: $input, _id: $id) {\n    _id\n    active\n    default\n    private\n    description\n    event\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    ticket_limit\n    title\n    offers {\n      _id\n      auto\n      broadcast_rooms\n      position\n      provider\n      provider_id\n      provider_network\n    }\n    limited\n    limited_whitelist_users {\n      _id\n      email\n    }\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nquery exportEventTickets($id: MongoID!, $ticketTypeIds: [MongoID!], $searchText: String, $pagination: PaginationInput, $checkedIn: Boolean) {\n  exportEventTickets(\n    _id: $id\n    ticket_type_ids: $ticketTypeIds\n    search_text: $searchText\n    pagination: $pagination\n    checked_in: $checkedIn\n  ) {\n    count\n    tickets {\n      _id\n      buyer_name\n      buyer_first_name\n      buyer_last_name\n      buyer_email\n      ticket_category\n      ticket_type\n      quantity\n      payment_amount\n      discount_amount\n      currency\n      discount_code\n      purchase_date\n      payment_provider\n      payment_id\n      checkin_date\n      is_assigned\n      assignee_email\n      assigned_to\n      assigned_email\n      is_issued\n      issued_by\n      is_claimed\n      active\n      cancelled_by\n      buyer_wallet\n      buyer_id\n      buyer_avatar\n      buyer_username\n      ticket_type_id\n      shortid\n    }\n  }\n}\n\nmutation CreateTickets($ticketType: MongoID!, $ticketAssignments: [TicketAssignment!]!) {\n  createTickets(ticket_type: $ticketType, ticket_assignments: $ticketAssignments) {\n    _id\n  }\n}\n\nquery CheckTicketTypePasscode($passcode: String!, $type: MongoID!) {\n  checkTicketTypePasscode(passcode: $passcode, type: $type)\n}": types.CalculateTicketsPricingDocument,
    "query GetMe {\n  getMe {\n    ...User\n    email\n    email_verified\n    wallets_new\n    wallet_custodial\n    stripe_connected_account {\n      account_id\n      connected\n    }\n    kratos_wallet_address\n    kratos_farcaster_fid\n    kratos_unicorn_wallet_address\n    oauth2_allow_creation\n    oauth2_clients\n    oauth2_max_clients\n  }\n}\n\nmutation SetUserWallet($token: String!, $signature: String!) {\n  setUserWallet(token: $token, signature: $signature)\n}\n\nmutation UpdateUser($input: UserInput!) {\n  updateUser(input: $input) {\n    ...User\n  }\n}\n\nquery SearchUsers($query: String!) {\n  searchUsers(query: $query) {\n    _id\n    email\n    name\n    display_name\n    new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n    }\n  }\n}\n\nquery GetUser($id: MongoID, $username: String, $email: String, $lens_profile_id: String) {\n  getUser(\n    _id: $id\n    username: $username\n    email: $email\n    lens_profile_id: $lens_profile_id\n  ) {\n    _id\n    name\n    display_name\n    email\n    username\n    description\n    followers\n    following\n    hosted\n    addresses {\n      _id\n      street_1\n      street_2\n      city\n      region\n      postal\n      country\n      title\n      phone\n      longitude\n      latitude\n      additional_directions\n    }\n    new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n    }\n    cover_expanded {\n      _id\n      bucket\n      url\n      type\n      key\n    }\n    handle_facebook\n    handle_instagram\n    handle_linkedin\n    handle_twitter\n    handle_farcaster\n    handle_github\n    created_at\n  }\n}\n\nmutation deleteUser {\n  deleteUser\n}\n\nmutation syncUserUnicornWallet {\n  syncUserUnicornWallet\n}\n\nquery UsernameAvailability($wallet: String!, $username: String!) {\n  isUsernameAvailable(wallet: $wallet, username: $username)\n}": types.GetMeDocument,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function graphql(source: string): unknown;

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetEvent($id: MongoID, $shortid: String) {\n  getEvent(_id: $id, shortid: $shortid) {\n    _id\n    title\n    description\n    approval_required\n    start\n    end\n    shortid\n    host\n    cohosts\n    host_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    accepted\n    new_new_photos_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    address_directions\n    subevent_enabled\n    sessions {\n      _id\n      start\n      end\n      broadcast\n      description\n      title\n      broadcast\n      photos_expanded {\n        _id\n        key\n        bucket\n      }\n      speaker_users\n      speaker_users_expanded {\n        ...User\n      }\n    }\n    space\n    space_expanded {\n      _id\n      title\n      image_avatar\n      image_avatar_expanded {\n        _id\n        bucket\n        url\n        type\n        key\n      }\n    }\n    timezone\n    application_questions {\n      _id\n      question\n      required\n      position\n      type\n      options\n      select_type\n    }\n    application_profile_fields {\n      field\n      question\n      required\n    }\n    self_verification {\n      config {\n        date_of_birth\n        excludedCountries\n        expiry_date\n        gender\n        issuing_state\n        minimumAge\n        name\n        nationality\n        ofac\n        passport_number\n      }\n      enabled\n    }\n    rsvp_wallet_platforms {\n      platform\n      required\n    }\n    calendar_links {\n      google\n      ical\n      outlook\n      yahoo\n    }\n    offers {\n      _id\n      provider\n      provider_id\n      provider_network\n    }\n    event_ticket_types {\n      _id\n      title\n      offers {\n        _id\n        provider_network\n        provider_id\n        provider\n      }\n    }\n    guest_limit\n    guest_limit_per\n    terms_text\n    virtual\n    virtual_url\n    theme_data\n    url\n    url_go\n    external_url\n    external_hostname\n    published\n    private\n    payment_accounts_new\n    payment_accounts_expanded {\n      ...PaymentAccount\n    }\n    layout_sections {\n      id\n      hidden\n    }\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n    hide_attending\n    registration_disabled\n    ticket_limit_per\n  }\n}\n\nquery GetEvents($subeventParent: MongoID, $skip: Int = 0, $limit: Int = 100, $id: [MongoID!], $site: MongoID, $search: String, $accepted: MongoID, $highlight: Boolean, $unpublished: Boolean, $startFrom: DateTimeISO, $startTo: DateTimeISO, $endFrom: DateTimeISO, $hostFilter: HostFilter, $sort: EventSortInput) {\n  getEvents(\n    subevent_parent: $subeventParent\n    skip: $skip\n    limit: $limit\n    _id: $id\n    site: $site\n    search: $search\n    accepted: $accepted\n    highlight: $highlight\n    unpublished: $unpublished\n    start_from: $startFrom\n    start_to: $startTo\n    end_from: $endFrom\n    host_filter: $hostFilter\n    sort: $sort\n  ) {\n    _id\n    shortid\n    title\n    host\n    host_expanded_new {\n      _id\n      name\n      image_avatar\n    }\n    cohosts\n    cohosts_expanded_new {\n      _id\n      name\n      image_avatar\n    }\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      url\n      type\n    }\n    start\n    end\n    timezone\n    event_ticket_types {\n      _id\n      title\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n    }\n    broadcasts {\n      provider_id\n    }\n    address {\n      title\n      city\n      title\n      region\n      additional_directions\n    }\n    accepted\n    sessions {\n      _id\n      broadcast\n      description\n      end\n      speaker_users\n      speaker_users_expanded {\n        _id\n        name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      start\n      title\n    }\n    subevent_parent_expanded {\n      _id\n      shortid\n      title\n      slug\n      start\n      timezone\n      new_new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n        type\n        url\n      }\n      subevent_settings {\n        ticket_required_for_creation\n        ticket_required_for_purchase\n      }\n    }\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    guests\n  }\n}\n\nquery GetUpcomingEvents($user: MongoID!, $limit: Int = 100, $skip: Int = 0, $host: Boolean, $sort: JSON, $site: MongoID, $unpublished: Boolean) {\n  events: getUpcomingEvents(\n    user: $user\n    limit: $limit\n    skip: $skip\n    host: $host\n    sort: $sort\n    site: $site\n    unpublished: $unpublished\n  ) {\n    _id\n    shortid\n    title\n    slug\n    host\n    host_expanded_new {\n      _id\n      name\n      new_photos_expanded {\n        _id\n        key\n        bucket\n      }\n    }\n    cohosts\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      type\n      url\n    }\n    start\n    end\n    timezone\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    me_awaiting_approval\n    published\n    private\n    guests\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n  }\n}\n\nquery GetPastEvents($user: MongoID!, $limit: Int = 100, $skip: Int = 0, $sort: JSON, $site: MongoID, $host: Boolean, $unpublished: Boolean) {\n  events: getPastEvents(\n    user: $user\n    limit: $limit\n    skip: $skip\n    sort: $sort\n    site: $site\n    host: $host\n    unpublished: $unpublished\n  ) {\n    _id\n    shortid\n    title\n    slug\n    host\n    host_expanded_new {\n      _id\n      name\n      new_photos_expanded {\n        _id\n        key\n        bucket\n      }\n    }\n    cohosts\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      type\n      url\n    }\n    start\n    end\n    timezone\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    me_awaiting_approval\n    published\n    private\n    guests\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n  }\n}\n\nquery getEventInvitation($event: MongoID!) {\n  getEventInvitation(event: $event) {\n    _id\n    inviters\n  }\n}\n\nquery GetEventTicketTypes($input: GetEventTicketTypesInput!) {\n  getEventTicketTypes(input: $input) {\n    ticket_types {\n      _id\n      title\n      default\n      description\n      event\n      limited\n      limit\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n      whitelisted\n      photos_expanded(limit: 1) {\n        _id\n        key\n        type\n        bucket\n      }\n      category\n      category_expanded {\n        _id\n        description\n        title\n        position\n      }\n      position\n      passcode_enabled\n      recommended_upgrade_ticket_types\n    }\n  }\n}\n\nquery getMyEventJoinRequest($event: MongoID!) {\n  getMyEventJoinRequest(event: $event) {\n    _id\n    created_at\n    decided_at\n    decided_by\n    decided_by_expanded {\n      _id\n      display_name\n      image_avatar\n      username\n      wallets\n    }\n    state\n    payment {\n      _id\n      state\n    }\n    requested_tickets {\n      count\n      ticket_type\n    }\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nmutation acceptEvent($id: MongoID!, $email: String) {\n  acceptEvent(_id: $id, email: $email) {\n    state\n  }\n}\n\nmutation SubmitEventApplicationAnswers($answers: [EventApplicationAnswerInput!]!, $event: MongoID!, $email: String) {\n  submitEventApplicationAnswers(answers: $answers, event: $event, email: $email)\n}\n\nquery PeekEventGuests($id: MongoID!, $limit: Int) {\n  peekEventGuests(_id: $id, limit: $limit) {\n    items {\n      _id\n      image_avatar\n      name\n      display_name\n      first_name\n    }\n    total\n  }\n}\n\nmutation UpdateEventTheme($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    theme_data\n  }\n}\n\nquery GetEventCohostInvites($input: GetEventCohostRequestsInput!) {\n  getEventCohostInvites(input: $input) {\n    event\n    from_expanded {\n      _id\n      name\n    }\n  }\n}\n\nmutation DecideEventCohostRequest($input: DecideEventCohostRequestInput!) {\n  decideEventCohostRequest(input: $input)\n}\n\nmutation createEvent($input: EventInput!) {\n  createEvent(input: $input) {\n    _id\n    shortid\n  }\n}\n\nmutation PublishEvent($event: MongoID!) {\n  updateEvent(_id: $event, input: {published: true}) {\n    _id\n    published\n  }\n}\n\nmutation UpdateEventSettings($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    title\n    description\n    start\n    end\n    timezone\n    theme_data\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    longitude\n    latitude\n    virtual_url\n    registration_disabled\n    guest_limit\n    terms_text\n    terms_link\n    shortid\n    private\n    layout_sections {\n      id\n      hidden\n    }\n  }\n}\n\nmutation UpdateEventPhotos($id: MongoID!, $new_new_photos: [MongoID!]) {\n  updateEvent(_id: $id, input: {new_new_photos: $new_new_photos}) {\n    new_new_photos\n    new_new_photos_expanded(limit: 50) {\n      _id\n      key\n      bucket\n    }\n  }\n}\n\nmutation inviteEvent($event: MongoID!, $users: [MongoID!], $emails: [String!], $custom_body_html: String) {\n  inviteEvent(\n    input: {_id: $event, users: $users, emails: $emails, custom_body_html: $custom_body_html}\n  ) {\n    _id\n    invited\n  }\n}\n\nmutation AssignTickets($input: AssignTicketsInput!) {\n  assignTickets(input: $input)\n}\n\nquery GetEventTicketSales($event: MongoID!) {\n  getEventTicketSales(event: $event) {\n    sales {\n      amount\n      currency\n      decimals\n    }\n    last_update\n  }\n}\n\nquery listEventTicketTypes($event: MongoID!) {\n  listEventTicketTypes(event: $event) {\n    limited_whitelist_users {\n      _id\n      email\n    }\n    _id\n    active\n    address_required\n    default\n    description\n    description_line\n    event\n    external_ids\n    limited\n    offers {\n      _id\n      auto\n      broadcast_rooms\n      position\n      provider\n      provider_id\n      provider_network\n    }\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n      type\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    private\n    ticket_count\n    ticket_limit\n    title\n    ticket_limit_per\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nquery ListEventTokenGates($event: MongoID!, $ticketTypes: [MongoID!]) {\n  listEventTokenGates(event: $event, ticket_types: $ticketTypes) {\n    _id\n    decimals\n    event\n    gated_ticket_types\n    is_nft\n    max_value\n    min_value\n    name\n    network\n    token_address\n  }\n}\n\nmutation CreateEventTokenGate($input: EventTokenGateInput!) {\n  createEventTokenGate(input: $input) {\n    _id\n  }\n}\n\nmutation UpdateEventTokenGate($input: EventTokenGateInput!) {\n  updateEventTokenGate(input: $input) {\n    _id\n  }\n}\n\nmutation ManageEventCohostRequests($input: ManageEventCohostRequestsInput!) {\n  manageEventCohostRequests(input: $input)\n}\n\nquery GetEventInvitedStatistics($id: MongoID!, $statuses: [InvitationResponse!], $limit: Float) {\n  getEventInvitedStatistics(_id: $id, statuses: $statuses, limit: $limit) {\n    emails_opened\n    guests {\n      user\n      pending\n      joined\n      email\n      declined\n      user_expanded {\n        _id\n        display_name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n    }\n    total\n    total_declined\n    total_joined\n  }\n}\n\nquery GetEventGuestsStatistics($event: MongoID!) {\n  getEventGuestsStatistics(event: $event) {\n    going\n    pending_approval\n    pending_invite\n    declined\n    checked_in\n  }\n}\n\nmutation UpdateEventRegistrationForm($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    rsvp_wallet_platforms {\n      platform\n      required\n    }\n  }\n}\n\nquery ListEventGuests($ticketTypes: [MongoID!], $going: Boolean, $pendingApproval: Boolean, $pendingInvite: Boolean, $declined: Boolean, $checkedIn: Boolean, $sortBy: ListEventGuestsSortBy, $sortOrder: SortOrder, $event: MongoID!, $search: String, $limit: Int, $skip: Int) {\n  listEventGuests(\n    ticket_types: $ticketTypes\n    going: $going\n    pending_approval: $pendingApproval\n    pending_invite: $pendingInvite\n    declined: $declined\n    checked_in: $checkedIn\n    sort_by: $sortBy\n    sort_order: $sortOrder\n    event: $event\n    search: $search\n    limit: $limit\n    skip: $skip\n  ) {\n    items {\n      join_request {\n        _id\n        state\n        non_login_user {\n          _id\n          display_name\n          email\n          image_avatar\n          name\n        }\n        user_expanded {\n          _id\n          display_name\n          email\n          image_avatar\n          name\n        }\n        metadata\n      }\n      ticket {\n        _id\n        created_at\n        type_expanded {\n          _id\n          title\n        }\n        metadata\n      }\n      user {\n        _id\n        display_name\n        email\n        image_avatar\n        name\n      }\n    }\n    total\n  }\n}\n\nquery GetEventGuestDetailedInfo($event: MongoID!, $email: String) {\n  getEventGuestDetailedInfo(event: $event, email: $email) {\n    checkin_count\n    purchased_tickets {\n      _id\n      type_expanded {\n        _id\n        title\n      }\n    }\n    ticket {\n      _id\n      created_at\n      type\n      type_expanded {\n        _id\n        title\n      }\n    }\n    user {\n      _id\n      description\n      display_name\n      email\n      first_name\n      image_avatar\n      last_name\n      name\n    }\n    payments {\n      _id\n      account_expanded {\n        ...PaymentAccount\n      }\n      amount\n      currency\n      crypto_payment_info {\n        network\n        tx_hash\n      }\n      stripe_payment_info {\n        card {\n          brand\n          last4\n        }\n        payment_intent\n      }\n      transfer_params\n      formatted_total_amount\n    }\n    join_request {\n      _id\n      state\n    }\n    application {\n      answer\n      answers\n      question\n    }\n  }\n}\n\nmutation submitEventApplicationQuestions($event: MongoID!, $questions: [QuestionInput!]!) {\n  submitEventApplicationQuestions(event: $event, questions: $questions) {\n    _id\n    question\n    required\n    position\n    type\n    options\n    select_type\n  }\n}\n\nmutation updateEventApplicationProfiles($fields: [ApplicationProfileFieldInput!], $id: MongoID!) {\n  updateEvent(input: {application_profile_fields: $fields}, _id: $id) {\n    application_profile_fields {\n      field\n      required\n      question\n    }\n  }\n}\n\nmutation decideUserJoinRequests($decision: EventJoinRequestState!, $event: MongoID!, $requests: [MongoID!]!) {\n  decideUserJoinRequests(\n    input: {decision: $decision, event: $event, requests: $requests}\n  ) {\n    _id\n    processed\n  }\n}\n\nquery getEventJoinRequests($event: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getEventJoinRequests(event: $event, skip: $skip, limit: $limit, state: $state) {\n    total\n    records {\n      _id\n      state\n      created_at\n      email\n      user\n      user_expanded {\n        _id\n        name\n        display_name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      non_login_user {\n        _id\n        name\n        email\n        display_name\n        username\n      }\n    }\n  }\n}\n\nquery GetListEventEmailSettings($event: MongoID!, $system: Boolean, $sent: Boolean, $scheduled: Boolean) {\n  listEventEmailSettings(\n    event: $event\n    system: $system\n    sent: $sent\n    scheduled: $scheduled\n  ) {\n    body_preview\n    _id\n    disabled\n    is_system_email\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    owner_expanded {\n      _id\n      image_avatar\n      new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n      }\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    scheduled_at\n    sent_at\n    subject_preview\n    type\n    custom_body_html\n    custom_subject_html\n    opened {\n      email\n      stamp\n    }\n  }\n}\n\nmutation UpdateEventEmailSetting($input: UpdateEventEmailSettingInput!) {\n  updateEventEmailSetting(input: $input) {\n    _id\n    body_preview\n    is_system_email\n    disabled\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    owner_expanded {\n      image_avatar\n    }\n    scheduled_at\n    sent_at\n    subject_preview\n    type\n    custom_body_html\n    custom_subject_html\n    template\n  }\n}\n\nmutation CreateEventEmailSetting($input: CreateEventEmailSettingInput!) {\n  createEventEmailSetting(input: $input) {\n    _id\n    body_preview\n    cc\n    custom_body_html\n    context\n    custom_subject_html\n    disabled\n    is_system_email\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    owner_expanded {\n      image_avatar\n    }\n    scheduled_at\n    sendgrid_template_id\n    sent_at\n    subject_preview\n    template\n    type\n    opened {\n      email\n      stamp\n    }\n  }\n}\n\nmutation DeleteEventEmailSetting($id: MongoID!) {\n  deleteEventEmailSetting(_id: $id)\n}\n\nmutation SendEventEmailSettingTestEmails($input: SendEventEmailSettingTestEmailsInput!) {\n  sendEventEmailSettingTestEmails(input: $input)\n}\n\nmutation ToggleEventEmailSettings($disabled: Boolean!, $ids: [MongoID!]!, $event: MongoID!) {\n  toggleEventEmailSettings(disabled: $disabled, ids: $ids, event: $event)\n}\n\nmutation UpdateEventToggleAttending($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    hide_attending\n  }\n}\n\nquery GetTickets($event: MongoID, $user: MongoID, $ticket_types: [MongoID!], $email: String) {\n  getTickets(\n    event: $event\n    user: $user\n    ticket_types: $ticket_types\n    email: $email\n  ) {\n    _id\n    accepted\n    assigned_email\n    assigned_to\n    assigned_to_expanded {\n      _id\n      name\n      new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n      }\n    }\n    event\n    invited_by\n    type\n    shortid\n  }\n}\n\nmutation CreatePoapDrop($input: CreatePoapInput!) {\n  createPoapDrop(input: $input) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nquery ListPoapDrops($event: MongoID!) {\n  listPoapDrops(event: $event) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n    minting_network\n  }\n}\n\nquery ListMyPoapClaims($event: MongoID) {\n  listMyPoapClaims(event: $event) {\n    drop {\n      _id\n    }\n    claimed_date\n  }\n}\n\nquery getEventCheckInState($id: MongoID) {\n  getEvent(_id: $id) {\n    checkedin\n  }\n}\n\nmutation ClaimPoap($wallet: String!, $drop: MongoID!) {\n  claimPoap(wallet: $wallet, drop: $drop)\n}\n\nmutation UpdatePoapDrop($input: UpdatePoapInput!, $drop: MongoID!) {\n  updatePoapDrop(input: $input, drop: $drop) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nquery GetPoapDropInfoById($getPoapDropInfoByIdId: Float!) {\n  getPoapDropInfoById(id: $getPoapDropInfoByIdId) {\n    description\n    image_url\n    name\n  }\n}\n\nquery CheckPoapDropEditCode($code: String!, $checkPoapDropEditCodeId: Int!) {\n  checkPoapDropEditCode(code: $code, id: $checkPoapDropEditCodeId)\n}\n\nmutation ImportPoapDrop($input: ImportPoapInput!, $code: String!, $importPoapDropId: Float!) {\n  importPoapDrop(input: $input, code: $code, id: $importPoapDropId) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nmutation CancelEvent($event: MongoID!) {\n  cancelEvent(_id: $event) {\n    _id\n  }\n}\n\nmutation cloneEvent($input: CloneEventInput!) {\n  cloneEvent(input: $input)\n}\n\nquery GenerateRecurringDates($input: GenerateRecurringDatesInput!) {\n  generateRecurringDates(input: $input)\n}\n\nmutation CreateEventTicketDiscounts($event: MongoID!, $inputs: [EventPaymentTicketDiscountInput!]!) {\n  createEventTicketDiscounts(event: $event, inputs: $inputs) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation UpdateEventTicketDiscount($event: MongoID!, $input: UpdateEventTicketDiscountInput!) {\n  updateEventTicketDiscount(event: $event, input: $input) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation DeleteEventTicketDiscounts($event: MongoID!, $discounts: [String!]!) {\n  deleteEventTicketDiscounts(event: $event, discounts: $discounts) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation UpdateEventSelfVerification($id: MongoID!, $self_verification: SelfVerificationInput) {\n  updateEvent(_id: $id, input: {self_verification: $self_verification}) {\n    self_verification {\n      config {\n        date_of_birth\n        excludedCountries\n        expiry_date\n        gender\n        issuing_state\n        minimumAge\n        name\n        nationality\n        ofac\n        passport_number\n      }\n      enabled\n    }\n  }\n}\n\nquery GetEventPaymentStatistics($event: MongoID!) {\n  getEventPaymentStatistics(event: $event) {\n    total_payments\n    stripe_payments {\n      count\n      revenue {\n        currency\n        formatted_total_amount\n      }\n    }\n    crypto_payments {\n      count\n      revenue {\n        currency\n        formatted_total_amount\n      }\n      networks {\n        chain_id\n        count\n      }\n    }\n  }\n}\n\nquery GetListEventPayments($skip: Int, $limit: Int, $event: MongoID!, $provider: NewPaymentProvider, $networks: [String!], $checked_in: Boolean, $ticket_types: [MongoID!], $search: String) {\n  listEventPayments(\n    skip: $skip\n    limit: $limit\n    event: $event\n    provider: $provider\n    networks: $networks\n    checked_in: $checked_in\n    ticket_types: $ticket_types\n    search: $search\n  ) {\n    records {\n      _id\n      account_expanded {\n        provider\n      }\n      stripe_payment_info {\n        payment_intent\n        card {\n          last4\n          brand\n        }\n      }\n      application {\n        question\n        answer\n      }\n      buyer_info {\n        email\n        name\n      }\n      buyer_user {\n        email\n        display_name\n        name\n        image_avatar\n      }\n      amount\n      currency\n      due_amount\n      fee\n      formatted_total_amount\n      formatted_discount_amount\n      currency\n      user\n      stamps\n      ticket_types_expanded {\n        _id\n        category_expanded {\n          title\n        }\n      }\n      state\n      account_expanded {\n        _id\n        active\n        created_at\n        user\n        type\n        title\n        provider\n      }\n      ref_data\n      transfer_params\n      transfer_metadata\n      crypto_payment_info {\n        network\n        tx_hash\n      }\n    }\n    total\n  }\n}\n\nquery getTicketStatistics($id: MongoID!) {\n  getTicketStatistics(id: $id) {\n    all\n    checked_in\n    invited\n    issued\n    cancelled\n    applicants {\n      state\n      count\n    }\n    not_checked_in\n    ticket_types {\n      ticket_type\n      ticket_type_title\n      count\n    }\n  }\n}"): (typeof documents)["query GetEvent($id: MongoID, $shortid: String) {\n  getEvent(_id: $id, shortid: $shortid) {\n    _id\n    title\n    description\n    approval_required\n    start\n    end\n    shortid\n    host\n    cohosts\n    host_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    accepted\n    new_new_photos_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    address_directions\n    subevent_enabled\n    sessions {\n      _id\n      start\n      end\n      broadcast\n      description\n      title\n      broadcast\n      photos_expanded {\n        _id\n        key\n        bucket\n      }\n      speaker_users\n      speaker_users_expanded {\n        ...User\n      }\n    }\n    space\n    space_expanded {\n      _id\n      title\n      image_avatar\n      image_avatar_expanded {\n        _id\n        bucket\n        url\n        type\n        key\n      }\n    }\n    timezone\n    application_questions {\n      _id\n      question\n      required\n      position\n      type\n      options\n      select_type\n    }\n    application_profile_fields {\n      field\n      question\n      required\n    }\n    self_verification {\n      config {\n        date_of_birth\n        excludedCountries\n        expiry_date\n        gender\n        issuing_state\n        minimumAge\n        name\n        nationality\n        ofac\n        passport_number\n      }\n      enabled\n    }\n    rsvp_wallet_platforms {\n      platform\n      required\n    }\n    calendar_links {\n      google\n      ical\n      outlook\n      yahoo\n    }\n    offers {\n      _id\n      provider\n      provider_id\n      provider_network\n    }\n    event_ticket_types {\n      _id\n      title\n      offers {\n        _id\n        provider_network\n        provider_id\n        provider\n      }\n    }\n    guest_limit\n    guest_limit_per\n    terms_text\n    virtual\n    virtual_url\n    theme_data\n    url\n    url_go\n    external_url\n    external_hostname\n    published\n    private\n    payment_accounts_new\n    payment_accounts_expanded {\n      ...PaymentAccount\n    }\n    layout_sections {\n      id\n      hidden\n    }\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n    hide_attending\n    registration_disabled\n    ticket_limit_per\n  }\n}\n\nquery GetEvents($subeventParent: MongoID, $skip: Int = 0, $limit: Int = 100, $id: [MongoID!], $site: MongoID, $search: String, $accepted: MongoID, $highlight: Boolean, $unpublished: Boolean, $startFrom: DateTimeISO, $startTo: DateTimeISO, $endFrom: DateTimeISO, $hostFilter: HostFilter, $sort: EventSortInput) {\n  getEvents(\n    subevent_parent: $subeventParent\n    skip: $skip\n    limit: $limit\n    _id: $id\n    site: $site\n    search: $search\n    accepted: $accepted\n    highlight: $highlight\n    unpublished: $unpublished\n    start_from: $startFrom\n    start_to: $startTo\n    end_from: $endFrom\n    host_filter: $hostFilter\n    sort: $sort\n  ) {\n    _id\n    shortid\n    title\n    host\n    host_expanded_new {\n      _id\n      name\n      image_avatar\n    }\n    cohosts\n    cohosts_expanded_new {\n      _id\n      name\n      image_avatar\n    }\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      url\n      type\n    }\n    start\n    end\n    timezone\n    event_ticket_types {\n      _id\n      title\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n    }\n    broadcasts {\n      provider_id\n    }\n    address {\n      title\n      city\n      title\n      region\n      additional_directions\n    }\n    accepted\n    sessions {\n      _id\n      broadcast\n      description\n      end\n      speaker_users\n      speaker_users_expanded {\n        _id\n        name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      start\n      title\n    }\n    subevent_parent_expanded {\n      _id\n      shortid\n      title\n      slug\n      start\n      timezone\n      new_new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n        type\n        url\n      }\n      subevent_settings {\n        ticket_required_for_creation\n        ticket_required_for_purchase\n      }\n    }\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n    guests\n  }\n}\n\nquery GetUpcomingEvents($user: MongoID!, $limit: Int = 100, $skip: Int = 0, $host: Boolean, $sort: JSON, $site: MongoID, $unpublished: Boolean) {\n  events: getUpcomingEvents(\n    user: $user\n    limit: $limit\n    skip: $skip\n    host: $host\n    sort: $sort\n    site: $site\n    unpublished: $unpublished\n  ) {\n    _id\n    shortid\n    title\n    slug\n    host\n    host_expanded_new {\n      _id\n      name\n      new_photos_expanded {\n        _id\n        key\n        bucket\n      }\n    }\n    cohosts\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      type\n      url\n    }\n    start\n    end\n    timezone\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    me_awaiting_approval\n    published\n    private\n    guests\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n  }\n}\n\nquery GetPastEvents($user: MongoID!, $limit: Int = 100, $skip: Int = 0, $sort: JSON, $site: MongoID, $host: Boolean, $unpublished: Boolean) {\n  events: getPastEvents(\n    user: $user\n    limit: $limit\n    skip: $skip\n    sort: $sort\n    site: $site\n    host: $host\n    unpublished: $unpublished\n  ) {\n    _id\n    shortid\n    title\n    slug\n    host\n    host_expanded_new {\n      _id\n      name\n      new_photos_expanded {\n        _id\n        key\n        bucket\n      }\n    }\n    cohosts\n    new_new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n      type\n      url\n    }\n    start\n    end\n    timezone\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    me_awaiting_approval\n    published\n    private\n    guests\n    visible_cohosts_expanded_new {\n      _id\n      name\n      display_name\n      email\n      image_avatar\n    }\n  }\n}\n\nquery getEventInvitation($event: MongoID!) {\n  getEventInvitation(event: $event) {\n    _id\n    inviters\n  }\n}\n\nquery GetEventTicketTypes($input: GetEventTicketTypesInput!) {\n  getEventTicketTypes(input: $input) {\n    ticket_types {\n      _id\n      title\n      default\n      description\n      event\n      limited\n      limit\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n      whitelisted\n      photos_expanded(limit: 1) {\n        _id\n        key\n        type\n        bucket\n      }\n      category\n      category_expanded {\n        _id\n        description\n        title\n        position\n      }\n      position\n      passcode_enabled\n      recommended_upgrade_ticket_types\n    }\n  }\n}\n\nquery getMyEventJoinRequest($event: MongoID!) {\n  getMyEventJoinRequest(event: $event) {\n    _id\n    created_at\n    decided_at\n    decided_by\n    decided_by_expanded {\n      _id\n      display_name\n      image_avatar\n      username\n      wallets\n    }\n    state\n    payment {\n      _id\n      state\n    }\n    requested_tickets {\n      count\n      ticket_type\n    }\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nmutation acceptEvent($id: MongoID!, $email: String) {\n  acceptEvent(_id: $id, email: $email) {\n    state\n  }\n}\n\nmutation SubmitEventApplicationAnswers($answers: [EventApplicationAnswerInput!]!, $event: MongoID!, $email: String) {\n  submitEventApplicationAnswers(answers: $answers, event: $event, email: $email)\n}\n\nquery PeekEventGuests($id: MongoID!, $limit: Int) {\n  peekEventGuests(_id: $id, limit: $limit) {\n    items {\n      _id\n      image_avatar\n      name\n      display_name\n      first_name\n    }\n    total\n  }\n}\n\nmutation UpdateEventTheme($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    theme_data\n  }\n}\n\nquery GetEventCohostInvites($input: GetEventCohostRequestsInput!) {\n  getEventCohostInvites(input: $input) {\n    event\n    from_expanded {\n      _id\n      name\n    }\n  }\n}\n\nmutation DecideEventCohostRequest($input: DecideEventCohostRequestInput!) {\n  decideEventCohostRequest(input: $input)\n}\n\nmutation createEvent($input: EventInput!) {\n  createEvent(input: $input) {\n    _id\n    shortid\n  }\n}\n\nmutation PublishEvent($event: MongoID!) {\n  updateEvent(_id: $event, input: {published: true}) {\n    _id\n    published\n  }\n}\n\nmutation UpdateEventSettings($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    title\n    description\n    start\n    end\n    timezone\n    theme_data\n    address {\n      street_1\n      city\n      title\n      region\n      country\n      additional_directions\n      latitude\n      longitude\n    }\n    longitude\n    latitude\n    virtual_url\n    registration_disabled\n    guest_limit\n    terms_text\n    terms_link\n    shortid\n    private\n    layout_sections {\n      id\n      hidden\n    }\n  }\n}\n\nmutation UpdateEventPhotos($id: MongoID!, $new_new_photos: [MongoID!]) {\n  updateEvent(_id: $id, input: {new_new_photos: $new_new_photos}) {\n    new_new_photos\n    new_new_photos_expanded(limit: 50) {\n      _id\n      key\n      bucket\n    }\n  }\n}\n\nmutation inviteEvent($event: MongoID!, $users: [MongoID!], $emails: [String!], $custom_body_html: String) {\n  inviteEvent(\n    input: {_id: $event, users: $users, emails: $emails, custom_body_html: $custom_body_html}\n  ) {\n    _id\n    invited\n  }\n}\n\nmutation AssignTickets($input: AssignTicketsInput!) {\n  assignTickets(input: $input)\n}\n\nquery GetEventTicketSales($event: MongoID!) {\n  getEventTicketSales(event: $event) {\n    sales {\n      amount\n      currency\n      decimals\n    }\n    last_update\n  }\n}\n\nquery listEventTicketTypes($event: MongoID!) {\n  listEventTicketTypes(event: $event) {\n    limited_whitelist_users {\n      _id\n      email\n    }\n    _id\n    active\n    address_required\n    default\n    description\n    description_line\n    event\n    external_ids\n    limited\n    offers {\n      _id\n      auto\n      broadcast_rooms\n      position\n      provider\n      provider_id\n      provider_network\n    }\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n      type\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    private\n    ticket_count\n    ticket_limit\n    title\n    ticket_limit_per\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nquery ListEventTokenGates($event: MongoID!, $ticketTypes: [MongoID!]) {\n  listEventTokenGates(event: $event, ticket_types: $ticketTypes) {\n    _id\n    decimals\n    event\n    gated_ticket_types\n    is_nft\n    max_value\n    min_value\n    name\n    network\n    token_address\n  }\n}\n\nmutation CreateEventTokenGate($input: EventTokenGateInput!) {\n  createEventTokenGate(input: $input) {\n    _id\n  }\n}\n\nmutation UpdateEventTokenGate($input: EventTokenGateInput!) {\n  updateEventTokenGate(input: $input) {\n    _id\n  }\n}\n\nmutation ManageEventCohostRequests($input: ManageEventCohostRequestsInput!) {\n  manageEventCohostRequests(input: $input)\n}\n\nquery GetEventInvitedStatistics($id: MongoID!, $statuses: [InvitationResponse!], $limit: Float) {\n  getEventInvitedStatistics(_id: $id, statuses: $statuses, limit: $limit) {\n    emails_opened\n    guests {\n      user\n      pending\n      joined\n      email\n      declined\n      user_expanded {\n        _id\n        display_name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n    }\n    total\n    total_declined\n    total_joined\n  }\n}\n\nquery GetEventGuestsStatistics($event: MongoID!) {\n  getEventGuestsStatistics(event: $event) {\n    going\n    pending_approval\n    pending_invite\n    declined\n    checked_in\n  }\n}\n\nmutation UpdateEventRegistrationForm($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    rsvp_wallet_platforms {\n      platform\n      required\n    }\n  }\n}\n\nquery ListEventGuests($ticketTypes: [MongoID!], $going: Boolean, $pendingApproval: Boolean, $pendingInvite: Boolean, $declined: Boolean, $checkedIn: Boolean, $sortBy: ListEventGuestsSortBy, $sortOrder: SortOrder, $event: MongoID!, $search: String, $limit: Int, $skip: Int) {\n  listEventGuests(\n    ticket_types: $ticketTypes\n    going: $going\n    pending_approval: $pendingApproval\n    pending_invite: $pendingInvite\n    declined: $declined\n    checked_in: $checkedIn\n    sort_by: $sortBy\n    sort_order: $sortOrder\n    event: $event\n    search: $search\n    limit: $limit\n    skip: $skip\n  ) {\n    items {\n      join_request {\n        _id\n        state\n        non_login_user {\n          _id\n          display_name\n          email\n          image_avatar\n          name\n        }\n        user_expanded {\n          _id\n          display_name\n          email\n          image_avatar\n          name\n        }\n        metadata\n      }\n      ticket {\n        _id\n        created_at\n        type_expanded {\n          _id\n          title\n        }\n        metadata\n      }\n      user {\n        _id\n        display_name\n        email\n        image_avatar\n        name\n      }\n    }\n    total\n  }\n}\n\nquery GetEventGuestDetailedInfo($event: MongoID!, $email: String) {\n  getEventGuestDetailedInfo(event: $event, email: $email) {\n    checkin_count\n    purchased_tickets {\n      _id\n      type_expanded {\n        _id\n        title\n      }\n    }\n    ticket {\n      _id\n      created_at\n      type\n      type_expanded {\n        _id\n        title\n      }\n    }\n    user {\n      _id\n      description\n      display_name\n      email\n      first_name\n      image_avatar\n      last_name\n      name\n    }\n    payments {\n      _id\n      account_expanded {\n        ...PaymentAccount\n      }\n      amount\n      currency\n      crypto_payment_info {\n        network\n        tx_hash\n      }\n      stripe_payment_info {\n        card {\n          brand\n          last4\n        }\n        payment_intent\n      }\n      transfer_params\n      formatted_total_amount\n    }\n    join_request {\n      _id\n      state\n    }\n    application {\n      answer\n      answers\n      question\n    }\n  }\n}\n\nmutation submitEventApplicationQuestions($event: MongoID!, $questions: [QuestionInput!]!) {\n  submitEventApplicationQuestions(event: $event, questions: $questions) {\n    _id\n    question\n    required\n    position\n    type\n    options\n    select_type\n  }\n}\n\nmutation updateEventApplicationProfiles($fields: [ApplicationProfileFieldInput!], $id: MongoID!) {\n  updateEvent(input: {application_profile_fields: $fields}, _id: $id) {\n    application_profile_fields {\n      field\n      required\n      question\n    }\n  }\n}\n\nmutation decideUserJoinRequests($decision: EventJoinRequestState!, $event: MongoID!, $requests: [MongoID!]!) {\n  decideUserJoinRequests(\n    input: {decision: $decision, event: $event, requests: $requests}\n  ) {\n    _id\n    processed\n  }\n}\n\nquery getEventJoinRequests($event: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getEventJoinRequests(event: $event, skip: $skip, limit: $limit, state: $state) {\n    total\n    records {\n      _id\n      state\n      created_at\n      email\n      user\n      user_expanded {\n        _id\n        name\n        display_name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      non_login_user {\n        _id\n        name\n        email\n        display_name\n        username\n      }\n    }\n  }\n}\n\nquery GetListEventEmailSettings($event: MongoID!, $system: Boolean, $sent: Boolean, $scheduled: Boolean) {\n  listEventEmailSettings(\n    event: $event\n    system: $system\n    sent: $sent\n    scheduled: $scheduled\n  ) {\n    body_preview\n    _id\n    disabled\n    is_system_email\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    owner_expanded {\n      _id\n      image_avatar\n      new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n      }\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    scheduled_at\n    sent_at\n    subject_preview\n    type\n    custom_body_html\n    custom_subject_html\n    opened {\n      email\n      stamp\n    }\n  }\n}\n\nmutation UpdateEventEmailSetting($input: UpdateEventEmailSettingInput!) {\n  updateEventEmailSetting(input: $input) {\n    _id\n    body_preview\n    is_system_email\n    disabled\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    owner_expanded {\n      image_avatar\n    }\n    scheduled_at\n    sent_at\n    subject_preview\n    type\n    custom_body_html\n    custom_subject_html\n    template\n  }\n}\n\nmutation CreateEventEmailSetting($input: CreateEventEmailSettingInput!) {\n  createEventEmailSetting(input: $input) {\n    _id\n    body_preview\n    cc\n    custom_body_html\n    context\n    custom_subject_html\n    disabled\n    is_system_email\n    recipient_types\n    recipients\n    recipients_details {\n      email\n      image_avatar\n    }\n    recipient_filters {\n      join_request_states\n      ticket_types\n    }\n    owner_expanded {\n      image_avatar\n    }\n    scheduled_at\n    sendgrid_template_id\n    sent_at\n    subject_preview\n    template\n    type\n    opened {\n      email\n      stamp\n    }\n  }\n}\n\nmutation DeleteEventEmailSetting($id: MongoID!) {\n  deleteEventEmailSetting(_id: $id)\n}\n\nmutation SendEventEmailSettingTestEmails($input: SendEventEmailSettingTestEmailsInput!) {\n  sendEventEmailSettingTestEmails(input: $input)\n}\n\nmutation ToggleEventEmailSettings($disabled: Boolean!, $ids: [MongoID!]!, $event: MongoID!) {\n  toggleEventEmailSettings(disabled: $disabled, ids: $ids, event: $event)\n}\n\nmutation UpdateEventToggleAttending($id: MongoID!, $input: EventInput!) {\n  updateEvent(_id: $id, input: $input) {\n    _id\n    hide_attending\n  }\n}\n\nquery GetTickets($event: MongoID, $user: MongoID, $ticket_types: [MongoID!], $email: String) {\n  getTickets(\n    event: $event\n    user: $user\n    ticket_types: $ticket_types\n    email: $email\n  ) {\n    _id\n    accepted\n    assigned_email\n    assigned_to\n    assigned_to_expanded {\n      _id\n      name\n      new_photos_expanded(limit: 1) {\n        _id\n        key\n        bucket\n      }\n    }\n    event\n    invited_by\n    type\n    shortid\n  }\n}\n\nmutation CreatePoapDrop($input: CreatePoapInput!) {\n  createPoapDrop(input: $input) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nquery ListPoapDrops($event: MongoID!) {\n  listPoapDrops(event: $event) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n    minting_network\n  }\n}\n\nquery ListMyPoapClaims($event: MongoID) {\n  listMyPoapClaims(event: $event) {\n    drop {\n      _id\n    }\n    claimed_date\n  }\n}\n\nquery getEventCheckInState($id: MongoID) {\n  getEvent(_id: $id) {\n    checkedin\n  }\n}\n\nmutation ClaimPoap($wallet: String!, $drop: MongoID!) {\n  claimPoap(wallet: $wallet, drop: $drop)\n}\n\nmutation UpdatePoapDrop($input: UpdatePoapInput!, $drop: MongoID!) {\n  updatePoapDrop(input: $input, drop: $drop) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nquery GetPoapDropInfoById($getPoapDropInfoByIdId: Float!) {\n  getPoapDropInfoById(id: $getPoapDropInfoByIdId) {\n    description\n    image_url\n    name\n  }\n}\n\nquery CheckPoapDropEditCode($code: String!, $checkPoapDropEditCodeId: Int!) {\n  checkPoapDropEditCode(code: $code, id: $checkPoapDropEditCodeId)\n}\n\nmutation ImportPoapDrop($input: ImportPoapInput!, $code: String!, $importPoapDropId: Float!) {\n  importPoapDrop(input: $input, code: $code, id: $importPoapDropId) {\n    _id\n    amount\n    claim_count\n    claim_mode\n    description\n    event\n    image\n    image_expanded {\n      _id\n      stamp\n      type\n      url\n      size\n      bucket\n      key\n    }\n    image_url\n    name\n    private\n    status\n    ticket_types\n    ticket_types_expanded {\n      _id\n      title\n    }\n  }\n}\n\nmutation CancelEvent($event: MongoID!) {\n  cancelEvent(_id: $event) {\n    _id\n  }\n}\n\nmutation cloneEvent($input: CloneEventInput!) {\n  cloneEvent(input: $input)\n}\n\nquery GenerateRecurringDates($input: GenerateRecurringDatesInput!) {\n  generateRecurringDates(input: $input)\n}\n\nmutation CreateEventTicketDiscounts($event: MongoID!, $inputs: [EventPaymentTicketDiscountInput!]!) {\n  createEventTicketDiscounts(event: $event, inputs: $inputs) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation UpdateEventTicketDiscount($event: MongoID!, $input: UpdateEventTicketDiscountInput!) {\n  updateEventTicketDiscount(event: $event, input: $input) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation DeleteEventTicketDiscounts($event: MongoID!, $discounts: [String!]!) {\n  deleteEventTicketDiscounts(event: $event, discounts: $discounts) {\n    _id\n    payment_ticket_discounts {\n      code\n      ratio\n      use_limit\n      use_limit_per\n      use_count\n      active\n      ticket_types\n    }\n  }\n}\n\nmutation UpdateEventSelfVerification($id: MongoID!, $self_verification: SelfVerificationInput) {\n  updateEvent(_id: $id, input: {self_verification: $self_verification}) {\n    self_verification {\n      config {\n        date_of_birth\n        excludedCountries\n        expiry_date\n        gender\n        issuing_state\n        minimumAge\n        name\n        nationality\n        ofac\n        passport_number\n      }\n      enabled\n    }\n  }\n}\n\nquery GetEventPaymentStatistics($event: MongoID!) {\n  getEventPaymentStatistics(event: $event) {\n    total_payments\n    stripe_payments {\n      count\n      revenue {\n        currency\n        formatted_total_amount\n      }\n    }\n    crypto_payments {\n      count\n      revenue {\n        currency\n        formatted_total_amount\n      }\n      networks {\n        chain_id\n        count\n      }\n    }\n  }\n}\n\nquery GetListEventPayments($skip: Int, $limit: Int, $event: MongoID!, $provider: NewPaymentProvider, $networks: [String!], $checked_in: Boolean, $ticket_types: [MongoID!], $search: String) {\n  listEventPayments(\n    skip: $skip\n    limit: $limit\n    event: $event\n    provider: $provider\n    networks: $networks\n    checked_in: $checked_in\n    ticket_types: $ticket_types\n    search: $search\n  ) {\n    records {\n      _id\n      account_expanded {\n        provider\n      }\n      stripe_payment_info {\n        payment_intent\n        card {\n          last4\n          brand\n        }\n      }\n      application {\n        question\n        answer\n      }\n      buyer_info {\n        email\n        name\n      }\n      buyer_user {\n        email\n        display_name\n        name\n        image_avatar\n      }\n      amount\n      currency\n      due_amount\n      fee\n      formatted_total_amount\n      formatted_discount_amount\n      currency\n      user\n      stamps\n      ticket_types_expanded {\n        _id\n        category_expanded {\n          title\n        }\n      }\n      state\n      account_expanded {\n        _id\n        active\n        created_at\n        user\n        type\n        title\n        provider\n      }\n      ref_data\n      transfer_params\n      transfer_metadata\n      crypto_payment_info {\n        network\n        tx_hash\n      }\n    }\n    total\n  }\n}\n\nquery getTicketStatistics($id: MongoID!) {\n  getTicketStatistics(id: $id) {\n    all\n    checked_in\n    invited\n    issued\n    cancelled\n    applicants {\n      state\n      count\n    }\n    not_checked_in\n    ticket_types {\n      ticket_type\n      ticket_type_title\n      count\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetSystemFiles($categories: [FileCategory!]) {\n  getSystemFiles(categories: $categories) {\n    _id\n    name\n    category\n    url\n    type\n    bucket\n    key\n  }\n}\n\nmutation createFileUploads($uploadInfos: [FileUploadInfo!]!, $directory: String!) {\n  createFileUploads(upload_infos: $uploadInfos, directory: $directory) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    presignedUrl: presigned_url\n  }\n}\n\nmutation confirmFileUploads($ids: [MongoID!]!) {\n  confirmFileUploads(ids: $ids)\n}\n\nmutation updateFileDescriptionMutation($input: FileInput!, $id: MongoID!) {\n  updateFile(input: $input, _id: $id) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    description\n  }\n}"): (typeof documents)["query GetSystemFiles($categories: [FileCategory!]) {\n  getSystemFiles(categories: $categories) {\n    _id\n    name\n    category\n    url\n    type\n    bucket\n    key\n  }\n}\n\nmutation createFileUploads($uploadInfos: [FileUploadInfo!]!, $directory: String!) {\n  createFileUploads(upload_infos: $uploadInfos, directory: $directory) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    presignedUrl: presigned_url\n  }\n}\n\nmutation confirmFileUploads($ids: [MongoID!]!) {\n  confirmFileUploads(ids: $ids)\n}\n\nmutation updateFileDescriptionMutation($input: FileInput!, $id: MongoID!) {\n  updateFile(input: $input, _id: $id) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    description\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment User on User {\n  _id\n  name\n  display_name\n  first_name\n  last_name\n  username\n  description\n  job_title\n  company_name\n  addresses {\n    _id\n    street_1\n    street_2\n    city\n    region\n    postal\n    country\n    title\n    phone\n    longitude\n    latitude\n    additional_directions\n  }\n  icebreakers {\n    _id\n    value\n    question_expanded {\n      _id\n      title\n    }\n  }\n  handle_facebook\n  handle_instagram\n  handle_linkedin\n  handle_twitter\n  handle_farcaster\n  handle_github\n  pronoun\n  calendly_url\n  website\n  new_photos_expanded(limit: 1) {\n    _id\n    key\n    bucket\n  }\n  url\n  url_go\n  lens_profile_synced\n  followers\n  following\n  hosted\n}\n\nfragment PaymentAccount on NewPaymentAccount {\n  _id\n  provider\n  type\n  title\n  account_info {\n    ... on EthereumAccount {\n      currencies\n      currency_map\n      address\n      network\n    }\n    ... on SafeAccount {\n      currencies\n      currency_map\n      address\n      network\n      owners\n      threshold\n      pending\n    }\n    ... on DigitalAccount {\n      currencies\n      currency_map\n      account_id\n    }\n    ... on StripeAccount {\n      currencies\n      currency_map\n      account_id\n      publishable_key\n    }\n    ... on EthereumEscrowAccount {\n      currencies\n      currency_map\n      address\n      network\n      minimum_deposit_percent\n      host_refund_percent\n      refund_policies {\n        percent\n        timestamp\n      }\n    }\n    ... on EthereumRelayAccount {\n      currencies\n      currency_map\n      address\n      network\n      payment_splitter_contract\n    }\n    ... on EthereumStakeAccount {\n      currencies\n      currency_map\n      address\n      network\n      config_id\n      requirement_checkin_before\n    }\n    ... on SolanaAccount {\n      currencies\n      currency_map\n      address\n      network\n    }\n  }\n}\n\nfragment AccountInfoFragment on AccountInfo {\n  ... on EthereumAccount {\n    currencies\n    currency_map\n    address\n    network\n  }\n  ... on SafeAccount {\n    currencies\n    currency_map\n    address\n    network\n    owners\n    threshold\n    pending\n  }\n  ... on DigitalAccount {\n    currencies\n    currency_map\n    account_id\n  }\n  ... on StripeAccount {\n    currencies\n    currency_map\n    account_id\n    publishable_key\n  }\n  ... on EthereumEscrowAccount {\n    currencies\n    currency_map\n    address\n    network\n    minimum_deposit_percent\n    host_refund_percent\n    refund_policies {\n      percent\n      timestamp\n    }\n  }\n  ... on EthereumRelayAccount {\n    currencies\n    currency_map\n    address\n    network\n    payment_splitter_contract\n  }\n  ... on EthereumStakeAccount {\n    currencies\n    currency_map\n    address\n    network\n    config_id\n    requirement_checkin_before\n  }\n  ... on SolanaAccount {\n    currencies\n    currency_map\n    address\n    network\n  }\n}"): (typeof documents)["fragment User on User {\n  _id\n  name\n  display_name\n  first_name\n  last_name\n  username\n  description\n  job_title\n  company_name\n  addresses {\n    _id\n    street_1\n    street_2\n    city\n    region\n    postal\n    country\n    title\n    phone\n    longitude\n    latitude\n    additional_directions\n  }\n  icebreakers {\n    _id\n    value\n    question_expanded {\n      _id\n      title\n    }\n  }\n  handle_facebook\n  handle_instagram\n  handle_linkedin\n  handle_twitter\n  handle_farcaster\n  handle_github\n  pronoun\n  calendly_url\n  website\n  new_photos_expanded(limit: 1) {\n    _id\n    key\n    bucket\n  }\n  url\n  url_go\n  lens_profile_synced\n  followers\n  following\n  hosted\n}\n\nfragment PaymentAccount on NewPaymentAccount {\n  _id\n  provider\n  type\n  title\n  account_info {\n    ... on EthereumAccount {\n      currencies\n      currency_map\n      address\n      network\n    }\n    ... on SafeAccount {\n      currencies\n      currency_map\n      address\n      network\n      owners\n      threshold\n      pending\n    }\n    ... on DigitalAccount {\n      currencies\n      currency_map\n      account_id\n    }\n    ... on StripeAccount {\n      currencies\n      currency_map\n      account_id\n      publishable_key\n    }\n    ... on EthereumEscrowAccount {\n      currencies\n      currency_map\n      address\n      network\n      minimum_deposit_percent\n      host_refund_percent\n      refund_policies {\n        percent\n        timestamp\n      }\n    }\n    ... on EthereumRelayAccount {\n      currencies\n      currency_map\n      address\n      network\n      payment_splitter_contract\n    }\n    ... on EthereumStakeAccount {\n      currencies\n      currency_map\n      address\n      network\n      config_id\n      requirement_checkin_before\n    }\n    ... on SolanaAccount {\n      currencies\n      currency_map\n      address\n      network\n    }\n  }\n}\n\nfragment AccountInfoFragment on AccountInfo {\n  ... on EthereumAccount {\n    currencies\n    currency_map\n    address\n    network\n  }\n  ... on SafeAccount {\n    currencies\n    currency_map\n    address\n    network\n    owners\n    threshold\n    pending\n  }\n  ... on DigitalAccount {\n    currencies\n    currency_map\n    account_id\n  }\n  ... on StripeAccount {\n    currencies\n    currency_map\n    account_id\n    publishable_key\n  }\n  ... on EthereumEscrowAccount {\n    currencies\n    currency_map\n    address\n    network\n    minimum_deposit_percent\n    host_refund_percent\n    refund_policies {\n      percent\n      timestamp\n    }\n  }\n  ... on EthereumRelayAccount {\n    currencies\n    currency_map\n    address\n    network\n    payment_splitter_contract\n  }\n  ... on EthereumStakeAccount {\n    currencies\n    currency_map\n    address\n    network\n    config_id\n    requirement_checkin_before\n  }\n  ... on SolanaAccount {\n    currencies\n    currency_map\n    address\n    network\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query ListLaunchpadGroups($address: String, $search: String) {\n  listLaunchpadGroups(address: $address, search: $search) {\n    items {\n      address\n      cover_photo\n      cover_photo_expanded {\n        _id\n        key\n        bucket\n      }\n      cover_photo_url\n      implementation_address\n      name\n    }\n  }\n}\n\nmutation AddLaunchpadCoin($input: LaunchpadCoinInput!) {\n  addLaunchpadCoin(input: $input) {\n    address\n  }\n}\n\nmutation AddLaunchpadGroup($input: AddLaunchpadGroupInput!) {\n  addLaunchpadGroup(input: $input) {\n    address\n  }\n}\n\nquery Items($skip: Int, $limit: Int, $address: String) {\n  listLaunchpadCoins(skip: $skip, limit: $limit, address: $address) {\n    items {\n      handle_telegram\n      handle_discord\n      handle_farcaster\n      handle_twitter\n      address\n      owner\n      website\n    }\n  }\n}"): (typeof documents)["query ListLaunchpadGroups($address: String, $search: String) {\n  listLaunchpadGroups(address: $address, search: $search) {\n    items {\n      address\n      cover_photo\n      cover_photo_expanded {\n        _id\n        key\n        bucket\n      }\n      cover_photo_url\n      implementation_address\n      name\n    }\n  }\n}\n\nmutation AddLaunchpadCoin($input: LaunchpadCoinInput!) {\n  addLaunchpadCoin(input: $input) {\n    address\n  }\n}\n\nmutation AddLaunchpadGroup($input: AddLaunchpadGroupInput!) {\n  addLaunchpadGroup(input: $input) {\n    address\n  }\n}\n\nquery Items($skip: Int, $limit: Int, $address: String) {\n  listLaunchpadCoins(skip: $skip, limit: $limit, address: $address) {\n    items {\n      handle_telegram\n      handle_discord\n      handle_farcaster\n      handle_twitter\n      address\n      owner\n      website\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetListLemonheadSponsors($wallet: String!) {\n  listLemonheadSponsors(wallet: $wallet) {\n    sponsors {\n      limit\n      sponsor {\n        _id\n        name\n        image_url\n        message\n      }\n      remaining\n    }\n  }\n}\n\nquery CanMintLemonhead($wallet: String!) {\n  canMintLemonhead(wallet: $wallet) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}\n\nquery CanMintPassport($wallet: String!, $provider: PassportProvider!) {\n  canMintPassport(wallet: $wallet, provider: $provider) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}\n\nquery GetListMyLemonheadInvitations {\n  listMyLemonheadInvitations {\n    invitations {\n      invitee_wallet\n      minted_at\n      user {\n        _id\n        username\n        image_avatar\n      }\n    }\n  }\n}\n\nquery GetMyLemonheadInvitationRank {\n  getMyLemonheadInvitationRank {\n    rank\n    user {\n      _id\n      name\n      display_name\n      username\n      image_avatar\n      lemonhead_inviter_wallet\n      kratos_wallet_address\n    }\n    invitations_count\n  }\n}\n\nquery GetLemonheadInvitationRank($skip: Int!, $limit: Int!) {\n  getLemonheadInvitationRank(skip: $skip, limit: $limit) {\n    items {\n      rank\n      user {\n        _id\n        name\n        display_name\n        username\n        image_avatar\n        lemonhead_inviter_wallet\n        kratos_wallet_address\n      }\n      invitations_count\n    }\n    total\n  }\n}\n\nmutation SetUserWallet($token: String!, $signature: String!) {\n  setUserWallet(token: $token, signature: $signature)\n}\n\nmutation UpdateMyLemonheadInvitations($invitations: [String!]!) {\n  updateMyLemonheadInvitations(invitations: $invitations) {\n    success\n    message\n    wallets\n  }\n}"): (typeof documents)["query GetListLemonheadSponsors($wallet: String!) {\n  listLemonheadSponsors(wallet: $wallet) {\n    sponsors {\n      limit\n      sponsor {\n        _id\n        name\n        image_url\n        message\n      }\n      remaining\n    }\n  }\n}\n\nquery CanMintLemonhead($wallet: String!) {\n  canMintLemonhead(wallet: $wallet) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}\n\nquery CanMintPassport($wallet: String!, $provider: PassportProvider!) {\n  canMintPassport(wallet: $wallet, provider: $provider) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}\n\nquery GetListMyLemonheadInvitations {\n  listMyLemonheadInvitations {\n    invitations {\n      invitee_wallet\n      minted_at\n      user {\n        _id\n        username\n        image_avatar\n      }\n    }\n  }\n}\n\nquery GetMyLemonheadInvitationRank {\n  getMyLemonheadInvitationRank {\n    rank\n    user {\n      _id\n      name\n      display_name\n      username\n      image_avatar\n      lemonhead_inviter_wallet\n      kratos_wallet_address\n    }\n    invitations_count\n  }\n}\n\nquery GetLemonheadInvitationRank($skip: Int!, $limit: Int!) {\n  getLemonheadInvitationRank(skip: $skip, limit: $limit) {\n    items {\n      rank\n      user {\n        _id\n        name\n        display_name\n        username\n        image_avatar\n        lemonhead_inviter_wallet\n        kratos_wallet_address\n      }\n      invitations_count\n    }\n    total\n  }\n}\n\nmutation SetUserWallet($token: String!, $signature: String!) {\n  setUserWallet(token: $token, signature: $signature)\n}\n\nmutation UpdateMyLemonheadInvitations($invitations: [String!]!) {\n  updateMyLemonheadInvitations(invitations: $invitations) {\n    success\n    message\n    wallets\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query listChains {\n  listChains {\n    active\n    platform\n    chain_id\n    name\n    code_name\n    rpc_url\n    block_explorer_url\n    block_explorer_name\n    block_explorer_for_tx\n    block_explorer_for_token\n    block_explorer_for_address\n    block_explorer_icon_url\n    block_time\n    safe_confirmations\n    logo_url\n    tokens {\n      active\n      name\n      symbol\n      decimals\n      contract\n      logo_url\n      is_native\n    }\n    access_registry_contract\n    poap_contract\n    marketplace_contract\n    marketplace_version\n    biconomy_api_key\n    ens_registry\n    proxy_admin_contract\n    payment_config_registry_contract\n    escrow_manager_contract\n    relay_payment_contract\n    stake_payment_contract\n    reward_registry_contract\n    eas_event_contract\n    eas_graphql_url\n    aragon_network\n    axelar_chain_name\n    donation_registry_contract\n    lemonhead_contract_address\n    lemonade_passport_contract_address\n    zugrama_passport_contract_address\n    vinyl_nation_passport_contract_address\n    drip_nation_passport_contract_address\n    festival_nation_passport_contract_address\n    lemonade_username_contract_address\n    poap_enabled\n    launchpad_closed_permissions_contract_address\n    launchpad_treasury_address_fee_split_manager_implementation_contract_address\n    launchpad_treasury_staking_manager_implementation_contract_address\n    launchpad_zap_contract_address\n    launchpad_fee_escrow_contract_address\n    launchpad_market_capped_price_contract_address\n    launchpad_market_utils_contract_address\n  }\n}\n\nquery GetUserWalletRequest($wallet: String!) {\n  getUserWalletRequest(wallet: $wallet) {\n    message\n    token\n  }\n}\n\nmutation createFileUploads($uploadInfos: [FileUploadInfo!]!, $directory: String!) {\n  createFileUploads(upload_infos: $uploadInfos, directory: $directory) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    presignedUrl: presigned_url\n  }\n}\n\nquery GetSelfVerificationStatus($config: SelfVerificationConfigInput!) {\n  getSelfVerificationStatus(config: $config) {\n    disclosures {\n      type\n      verified\n    }\n  }\n}\n\nmutation CreateSelfVerificationRequest($config: SelfVerificationConfigInput!) {\n  createSelfVerificationRequest(config: $config) {\n    endpoint\n    endpoint_type\n    scope\n    uuid\n  }\n}"): (typeof documents)["query listChains {\n  listChains {\n    active\n    platform\n    chain_id\n    name\n    code_name\n    rpc_url\n    block_explorer_url\n    block_explorer_name\n    block_explorer_for_tx\n    block_explorer_for_token\n    block_explorer_for_address\n    block_explorer_icon_url\n    block_time\n    safe_confirmations\n    logo_url\n    tokens {\n      active\n      name\n      symbol\n      decimals\n      contract\n      logo_url\n      is_native\n    }\n    access_registry_contract\n    poap_contract\n    marketplace_contract\n    marketplace_version\n    biconomy_api_key\n    ens_registry\n    proxy_admin_contract\n    payment_config_registry_contract\n    escrow_manager_contract\n    relay_payment_contract\n    stake_payment_contract\n    reward_registry_contract\n    eas_event_contract\n    eas_graphql_url\n    aragon_network\n    axelar_chain_name\n    donation_registry_contract\n    lemonhead_contract_address\n    lemonade_passport_contract_address\n    zugrama_passport_contract_address\n    vinyl_nation_passport_contract_address\n    drip_nation_passport_contract_address\n    festival_nation_passport_contract_address\n    lemonade_username_contract_address\n    poap_enabled\n    launchpad_closed_permissions_contract_address\n    launchpad_treasury_address_fee_split_manager_implementation_contract_address\n    launchpad_treasury_staking_manager_implementation_contract_address\n    launchpad_zap_contract_address\n    launchpad_fee_escrow_contract_address\n    launchpad_market_capped_price_contract_address\n    launchpad_market_utils_contract_address\n  }\n}\n\nquery GetUserWalletRequest($wallet: String!) {\n  getUserWalletRequest(wallet: $wallet) {\n    message\n    token\n  }\n}\n\nmutation createFileUploads($uploadInfos: [FileUploadInfo!]!, $directory: String!) {\n  createFileUploads(upload_infos: $uploadInfos, directory: $directory) {\n    _id\n    stamp\n    state\n    owner\n    type\n    size\n    url\n    bucket\n    key\n    presignedUrl: presigned_url\n  }\n}\n\nquery GetSelfVerificationStatus($config: SelfVerificationConfigInput!) {\n  getSelfVerificationStatus(config: $config) {\n    disclosures {\n      type\n      verified\n    }\n  }\n}\n\nmutation CreateSelfVerificationRequest($config: SelfVerificationConfigInput!) {\n  createSelfVerificationRequest(config: $config) {\n    endpoint\n    endpoint_type\n    scope\n    uuid\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation CreateOauth2Client($input: Oauth2ClientInput!) {\n  createOauth2Client(input: $input) {\n    client_id\n    client_secret\n    audience\n  }\n}"): (typeof documents)["mutation CreateOauth2Client($input: Oauth2ClientInput!) {\n  createOauth2Client(input: $input) {\n    client_id\n    client_secret\n    audience\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query CanMintPassport($wallet: String!, $provider: PassportProvider!) {\n  canMintPassport(wallet: $wallet, provider: $provider) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}"): (typeof documents)["query CanMintPassport($wallet: String!, $provider: PassportProvider!) {\n  canMintPassport(wallet: $wallet, provider: $provider) {\n    can_mint\n    price\n    white_list_enabled\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation createStripeCard($paymentMethod: String!) {\n  createStripeCard(payment_method: $paymentMethod) {\n    _id\n    provider_id\n  }\n}\n\nquery getStripeCards {\n  getStripeCards {\n    _id\n    active\n    brand\n    last4\n    name\n    provider_id\n    stamp\n    user\n  }\n}\n\nmutation updatePayment($input: UpdatePaymentInput!) {\n  updatePayment(input: $input) {\n    _id\n    transfer_metadata\n    state\n    failure_reason\n  }\n}\n\nquery getNewPayment($id: MongoID!, $paymentSecret: String) {\n  getNewPayment(_id: $id, payment_secret: $paymentSecret) {\n    _id\n    due_amount\n    amount\n    currency\n    ref_data\n    state\n    failure_reason\n    account_expanded {\n      _id\n      type\n      account_info {\n        ... on EthereumEscrowAccount {\n          currencies\n          currency_map\n          address\n          network\n          minimum_deposit_percent\n          host_refund_percent\n          refund_policies {\n            percent\n            timestamp\n          }\n        }\n      }\n    }\n  }\n}\n\nquery getPaymentRefundSignature($id: MongoID!) {\n  getPaymentRefundSignature(_id: $id) {\n    args\n    signature\n  }\n}\n\nmutation CancelPayment($input: CancelPaymentInput!) {\n  cancelPayment(input: $input)\n}\n\nmutation GenerateStripeAccountLink($refreshUrl: String!, $returnUrl: String!) {\n  generateStripeAccountLink(refresh_url: $refreshUrl, return_url: $returnUrl) {\n    url\n  }\n}\n\nquery listNewPaymentAccounts($id: [MongoID!], $type: PaymentAccountType, $provider: NewPaymentProvider) {\n  listNewPaymentAccounts(_id: $id, type: $type, provider: $provider) {\n    _id\n    account_info {\n      ...AccountInfoFragment\n    }\n    active\n    provider\n    created_at\n    type\n    user\n    title\n  }\n}\n\nmutation createNewPaymentAccount($type: PaymentAccountType!, $provider: NewPaymentProvider, $account_info: JSON) {\n  createNewPaymentAccount(\n    input: {type: $type, provider: $provider, account_info: $account_info}\n  ) {\n    _id\n    account_info {\n      ...AccountInfoFragment\n    }\n    active\n    provider\n    created_at\n    type\n    user\n    title\n  }\n}\n\nmutation updateEventPaymentAccounts($id: MongoID!, $payment_accounts_new: [MongoID!]) {\n  updateEvent(_id: $id, input: {payment_accounts_new: $payment_accounts_new}) {\n    payment_accounts_new\n    payment_accounts_expanded {\n      ...PaymentAccount\n    }\n  }\n}"): (typeof documents)["mutation createStripeCard($paymentMethod: String!) {\n  createStripeCard(payment_method: $paymentMethod) {\n    _id\n    provider_id\n  }\n}\n\nquery getStripeCards {\n  getStripeCards {\n    _id\n    active\n    brand\n    last4\n    name\n    provider_id\n    stamp\n    user\n  }\n}\n\nmutation updatePayment($input: UpdatePaymentInput!) {\n  updatePayment(input: $input) {\n    _id\n    transfer_metadata\n    state\n    failure_reason\n  }\n}\n\nquery getNewPayment($id: MongoID!, $paymentSecret: String) {\n  getNewPayment(_id: $id, payment_secret: $paymentSecret) {\n    _id\n    due_amount\n    amount\n    currency\n    ref_data\n    state\n    failure_reason\n    account_expanded {\n      _id\n      type\n      account_info {\n        ... on EthereumEscrowAccount {\n          currencies\n          currency_map\n          address\n          network\n          minimum_deposit_percent\n          host_refund_percent\n          refund_policies {\n            percent\n            timestamp\n          }\n        }\n      }\n    }\n  }\n}\n\nquery getPaymentRefundSignature($id: MongoID!) {\n  getPaymentRefundSignature(_id: $id) {\n    args\n    signature\n  }\n}\n\nmutation CancelPayment($input: CancelPaymentInput!) {\n  cancelPayment(input: $input)\n}\n\nmutation GenerateStripeAccountLink($refreshUrl: String!, $returnUrl: String!) {\n  generateStripeAccountLink(refresh_url: $refreshUrl, return_url: $returnUrl) {\n    url\n  }\n}\n\nquery listNewPaymentAccounts($id: [MongoID!], $type: PaymentAccountType, $provider: NewPaymentProvider) {\n  listNewPaymentAccounts(_id: $id, type: $type, provider: $provider) {\n    _id\n    account_info {\n      ...AccountInfoFragment\n    }\n    active\n    provider\n    created_at\n    type\n    user\n    title\n  }\n}\n\nmutation createNewPaymentAccount($type: PaymentAccountType!, $provider: NewPaymentProvider, $account_info: JSON) {\n  createNewPaymentAccount(\n    input: {type: $type, provider: $provider, account_info: $account_info}\n  ) {\n    _id\n    account_info {\n      ...AccountInfoFragment\n    }\n    active\n    provider\n    created_at\n    type\n    user\n    title\n  }\n}\n\nmutation updateEventPaymentAccounts($id: MongoID!, $payment_accounts_new: [MongoID!]) {\n  updateEvent(_id: $id, input: {payment_accounts_new: $payment_accounts_new}) {\n    payment_accounts_new\n    payment_accounts_expanded {\n      ...PaymentAccount\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment Space on Space {\n  _id\n  title\n  admins {\n    _id\n    image_avatar\n  }\n  description\n  is_ambassador\n  followed\n  followers\n  followers_count\n  image_avatar\n  image_avatar_expanded {\n    _id\n    bucket\n    url\n    type\n    key\n  }\n  image_cover\n  image_cover_expanded {\n    _id\n    bucket\n    url\n    type\n    key\n  }\n  creator\n  creator_expanded {\n    _id\n    name\n    image_avatar\n  }\n  slug\n  private\n  listed_events\n  website\n  address {\n    _id\n    city\n    country\n    latitude\n    longitude\n    street_1\n    street_2\n    region\n    title\n  }\n  handle_instagram\n  handle_twitter\n  handle_linkedin\n  handle_youtube\n  handle_tiktok\n  personal\n  theme_data\n  sub_spaces\n  lens_feed_id\n  council_members {\n    user {\n      _id\n      display_name\n      username\n      image_avatar\n    }\n    wallet\n  }\n  state\n}\n\nfragment SpaceTagFragment on SpaceTag {\n  _id\n  color\n  space\n  tag\n  targets\n  type\n}\n\nfragment SpaceEventRequestFragment on SpaceEventRequest {\n  _id\n  created_at\n  space\n  event\n  state\n  decided_at\n  decided_by\n}\n\nquery GetSpaces($with_my_spaces: Boolean, $with_public_spaces: Boolean, $roles: [SpaceRole!], $featured: Boolean) {\n  listSpaces(\n    with_my_spaces: $with_my_spaces\n    with_public_spaces: $with_public_spaces\n    roles: $roles\n    featured: $featured\n  ) {\n    ...Space\n  }\n}\n\nquery GetSpace($id: MongoID, $slug: String, $hostname: String) {\n  getSpace(_id: $id, slug: $slug, hostname: $hostname) {\n    ...Space\n  }\n}\n\nquery GetSpaceEvents($skip: Int, $limit: Int, $startFrom: DateTimeISO, $startTo: DateTimeISO, $space: MongoID, $sort: EventSortInput, $endFrom: DateTimeISO, $endTo: DateTimeISO, $spaceTags: [MongoID!]) {\n  getEvents(\n    skip: $skip\n    limit: $limit\n    start_from: $startFrom\n    start_to: $startTo\n    space: $space\n    sort: $sort\n    end_from: $endFrom\n    end_to: $endTo\n    space_tags: $spaceTags\n  ) {\n    _id\n    shortid\n    title\n    host_expanded_new {\n      _id\n      image_avatar\n      name\n    }\n    visible_cohosts_expanded_new {\n      _id\n      image_avatar\n      name\n    }\n    address {\n      city\n      country\n      region\n      latitude\n      longitude\n    }\n    new_new_photos_expanded {\n      _id\n      bucket\n      key\n      type\n      url\n    }\n    published\n    start\n    end\n    timezone\n    external_url\n    external_hostname\n    event_ticket_types {\n      _id\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n    }\n    host_expanded_new {\n      _id\n      image_avatar\n    }\n    visible_cohosts_expanded_new {\n      _id\n      image_avatar\n    }\n  }\n}\n\nquery GetSpaceEventsCalendar($space: MongoID) {\n  getEvents(space: $space) {\n    _id\n    start\n    address {\n      _id\n      latitude\n      longitude\n    }\n  }\n}\n\nquery GetSpaceTags($space: MongoID!) {\n  listSpaceTags(space: $space) {\n    ...SpaceTagFragment\n  }\n}\n\nquery GetSpaceEventRequests($space: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getSpaceEventRequests(space: $space, skip: $skip, limit: $limit, state: $state) {\n    records {\n      _id\n      created_at\n      space\n      event\n      state\n      decided_at\n      decided_by\n      created_by_expanded {\n        name\n        display_name\n        email\n      }\n      event_expanded {\n        title\n        start\n        timezone\n        address {\n          city\n          country\n          region\n        }\n        new_new_photos_expanded {\n          _id\n          bucket\n          key\n          type\n          url\n        }\n        guests\n      }\n    }\n    total\n  }\n}\n\nquery GetMySpaceEventRequests($space: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getMySpaceEventRequests(\n    space: $space\n    skip: $skip\n    limit: $limit\n    state: $state\n  ) {\n    records {\n      _id\n      state\n      event_expanded {\n        _id\n        title\n        new_new_photos_expanded {\n          key\n          bucket\n          _id\n          url\n          type\n        }\n      }\n    }\n  }\n}\n\nquery getSubSpaces($id: MongoID!) {\n  getSubSpaces(_id: $id) {\n    _id\n    title\n    description\n    followers_count\n    slug\n    is_admin\n    followed\n    image_avatar_expanded {\n      _id\n      bucket\n      url\n      type\n      key\n    }\n  }\n}\n\nquery GetListSpaceCategories {\n  listSpaceCategories {\n    description\n    image_url\n    listed_events_count\n    space\n    title\n  }\n}\n\nquery GetListGeoRegions {\n  listGeoRegions {\n    _id\n    title\n    cities {\n      name\n      region\n      space\n      icon_url\n      listed_events_count\n    }\n  }\n}\n\nquery CheckSpaceSlug($slug: String!) {\n  canUseSpaceSlug(slug: $slug)\n}\n\nquery SearchSpaces($skip: Int, $limit: Int, $input: SearchSpaceInput) {\n  searchSpaces(input: $input, limit: $limit, skip: $skip) {\n    items {\n      ...Space\n    }\n    total\n  }\n}\n\nquery GetSpaceMembers($space: MongoID!, $roles: [SpaceRole!], $state: SpaceMembershipState, $visible: Boolean, $skip: Int, $limit: Int, $search: String, $sort: SortInput, $deletion: Boolean, $tags: [MongoID!]) {\n  listSpaceMembers(\n    space: $space\n    roles: $roles\n    state: $state\n    visible: $visible\n    skip: $skip\n    limit: $limit\n    search: $search\n    sort: $sort\n    deletion: $deletion\n    tags: $tags\n  ) {\n    total\n    items {\n      _id\n      user\n      user_name\n      email\n      space\n      role\n      state\n      visible\n      role_changed_at\n      deleted_at\n      user_expanded {\n        _id\n        name\n        display_name\n        email\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      event_count\n      checkin_count\n      tags {\n        _id\n        space\n        tag\n        color\n        type\n        targets\n        targets_count\n      }\n    }\n  }\n}\n\nmutation FollowSpace($space: MongoID!) {\n  followSpace(space: $space)\n}\n\nmutation UnfollowSpace($space: MongoID!) {\n  unfollowSpace(space: $space)\n}\n\nmutation UpdateSpace($id: MongoID!, $input: SpaceInput!) {\n  updateSpace(_id: $id, input: $input) {\n    ...Space\n  }\n}\n\nmutation PinEventsToSpace($space: MongoID!, $events: [MongoID!]!, $tags: [MongoID!]) {\n  pinEventsToSpace(space: $space, events: $events, tags: $tags) {\n    requests {\n      ...SpaceEventRequestFragment\n    }\n  }\n}\n\nmutation CreateExternalEvent($input: EventInput!) {\n  createEvent(input: $input) {\n    _id\n  }\n}\n\nmutation CreateSpace($input: SpaceInput!) {\n  createSpace(input: $input) {\n    ...Space\n  }\n}\n\nmutation DecideSpaceEventRequests($input: DecideSpaceEventRequestsInput!) {\n  decideSpaceEventRequests(input: $input)\n}\n\nmutation AddSpaceMembers($input: AddSpaceMemberInput!) {\n  addSpaceMembers(input: $input)\n}\n\nmutation DeleteSpaceMembers($input: DeleteSpaceMemberInput!) {\n  deleteSpaceMembers(input: $input) {\n    _id\n    role\n    state\n    user\n    user_name\n    email\n    deleted_at\n    role_changed_at\n    user_expanded {\n      _id\n      name\n      email\n      image_avatar\n    }\n    visible\n  }\n}\n\nmutation DeleteSpace($id: MongoID!) {\n  deleteSpace(_id: $id)\n}\n\nmutation UpsertSpaceTag($input: SpaceTagInput!) {\n  insertSpaceTag(input: $input) {\n    ...SpaceTagFragment\n  }\n}\n\nmutation ManageSpaceTag($tagged: Boolean!, $target: String!, $id: MongoID!, $space: MongoID!) {\n  manageSpaceTag(tagged: $tagged, target: $target, _id: $id, space: $space)\n}\n\nmutation DeleteSpaceTag($id: MongoID!, $space: MongoID!) {\n  deleteSpaceTag(_id: $id, space: $space)\n}\n\nmutation AttachSubSpaces($id: MongoID!, $subSpaces: [String!]!) {\n  attachSubSpaces(_id: $id, sub_spaces: $subSpaces)\n}\n\nmutation RemoveSubSpaces($subSpaces: [MongoID!]!, $id: MongoID!) {\n  removeSubSpaces(sub_spaces: $subSpaces, _id: $id)\n}\n\nmutation UpdateSubSpaceOrder($id: MongoID!, $subSpaces: [MongoID!]!) {\n  updateSubSpaceOrder(_id: $id, sub_spaces: $subSpaces)\n}\n\nmutation UpsertSpaceTag($input: SpaceTagInput!) {\n  insertSpaceTag(input: $input) {\n    ...SpaceTagFragment\n  }\n}\n\nmutation DeleteSpaceTag($id: MongoID!, $space: MongoID!) {\n  deleteSpaceTag(_id: $id, space: $space)\n}"): (typeof documents)["fragment Space on Space {\n  _id\n  title\n  admins {\n    _id\n    image_avatar\n  }\n  description\n  is_ambassador\n  followed\n  followers\n  followers_count\n  image_avatar\n  image_avatar_expanded {\n    _id\n    bucket\n    url\n    type\n    key\n  }\n  image_cover\n  image_cover_expanded {\n    _id\n    bucket\n    url\n    type\n    key\n  }\n  creator\n  creator_expanded {\n    _id\n    name\n    image_avatar\n  }\n  slug\n  private\n  listed_events\n  website\n  address {\n    _id\n    city\n    country\n    latitude\n    longitude\n    street_1\n    street_2\n    region\n    title\n  }\n  handle_instagram\n  handle_twitter\n  handle_linkedin\n  handle_youtube\n  handle_tiktok\n  personal\n  theme_data\n  sub_spaces\n  lens_feed_id\n  council_members {\n    user {\n      _id\n      display_name\n      username\n      image_avatar\n    }\n    wallet\n  }\n  state\n}\n\nfragment SpaceTagFragment on SpaceTag {\n  _id\n  color\n  space\n  tag\n  targets\n  type\n}\n\nfragment SpaceEventRequestFragment on SpaceEventRequest {\n  _id\n  created_at\n  space\n  event\n  state\n  decided_at\n  decided_by\n}\n\nquery GetSpaces($with_my_spaces: Boolean, $with_public_spaces: Boolean, $roles: [SpaceRole!], $featured: Boolean) {\n  listSpaces(\n    with_my_spaces: $with_my_spaces\n    with_public_spaces: $with_public_spaces\n    roles: $roles\n    featured: $featured\n  ) {\n    ...Space\n  }\n}\n\nquery GetSpace($id: MongoID, $slug: String, $hostname: String) {\n  getSpace(_id: $id, slug: $slug, hostname: $hostname) {\n    ...Space\n  }\n}\n\nquery GetSpaceEvents($skip: Int, $limit: Int, $startFrom: DateTimeISO, $startTo: DateTimeISO, $space: MongoID, $sort: EventSortInput, $endFrom: DateTimeISO, $endTo: DateTimeISO, $spaceTags: [MongoID!]) {\n  getEvents(\n    skip: $skip\n    limit: $limit\n    start_from: $startFrom\n    start_to: $startTo\n    space: $space\n    sort: $sort\n    end_from: $endFrom\n    end_to: $endTo\n    space_tags: $spaceTags\n  ) {\n    _id\n    shortid\n    title\n    host_expanded_new {\n      _id\n      image_avatar\n      name\n    }\n    visible_cohosts_expanded_new {\n      _id\n      image_avatar\n      name\n    }\n    address {\n      city\n      country\n      region\n      latitude\n      longitude\n    }\n    new_new_photos_expanded {\n      _id\n      bucket\n      key\n      type\n      url\n    }\n    published\n    start\n    end\n    timezone\n    external_url\n    external_hostname\n    event_ticket_types {\n      _id\n      prices {\n        cost\n        currency\n        default\n        payment_accounts\n        payment_accounts_expanded {\n          ...PaymentAccount\n        }\n      }\n    }\n    host_expanded_new {\n      _id\n      image_avatar\n    }\n    visible_cohosts_expanded_new {\n      _id\n      image_avatar\n    }\n  }\n}\n\nquery GetSpaceEventsCalendar($space: MongoID) {\n  getEvents(space: $space) {\n    _id\n    start\n    address {\n      _id\n      latitude\n      longitude\n    }\n  }\n}\n\nquery GetSpaceTags($space: MongoID!) {\n  listSpaceTags(space: $space) {\n    ...SpaceTagFragment\n  }\n}\n\nquery GetSpaceEventRequests($space: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getSpaceEventRequests(space: $space, skip: $skip, limit: $limit, state: $state) {\n    records {\n      _id\n      created_at\n      space\n      event\n      state\n      decided_at\n      decided_by\n      created_by_expanded {\n        name\n        display_name\n        email\n      }\n      event_expanded {\n        title\n        start\n        timezone\n        address {\n          city\n          country\n          region\n        }\n        new_new_photos_expanded {\n          _id\n          bucket\n          key\n          type\n          url\n        }\n        guests\n      }\n    }\n    total\n  }\n}\n\nquery GetMySpaceEventRequests($space: MongoID!, $skip: Int!, $limit: Int!, $state: EventJoinRequestState) {\n  getMySpaceEventRequests(\n    space: $space\n    skip: $skip\n    limit: $limit\n    state: $state\n  ) {\n    records {\n      _id\n      state\n      event_expanded {\n        _id\n        title\n        new_new_photos_expanded {\n          key\n          bucket\n          _id\n          url\n          type\n        }\n      }\n    }\n  }\n}\n\nquery getSubSpaces($id: MongoID!) {\n  getSubSpaces(_id: $id) {\n    _id\n    title\n    description\n    followers_count\n    slug\n    is_admin\n    followed\n    image_avatar_expanded {\n      _id\n      bucket\n      url\n      type\n      key\n    }\n  }\n}\n\nquery GetListSpaceCategories {\n  listSpaceCategories {\n    description\n    image_url\n    listed_events_count\n    space\n    title\n  }\n}\n\nquery GetListGeoRegions {\n  listGeoRegions {\n    _id\n    title\n    cities {\n      name\n      region\n      space\n      icon_url\n      listed_events_count\n    }\n  }\n}\n\nquery CheckSpaceSlug($slug: String!) {\n  canUseSpaceSlug(slug: $slug)\n}\n\nquery SearchSpaces($skip: Int, $limit: Int, $input: SearchSpaceInput) {\n  searchSpaces(input: $input, limit: $limit, skip: $skip) {\n    items {\n      ...Space\n    }\n    total\n  }\n}\n\nquery GetSpaceMembers($space: MongoID!, $roles: [SpaceRole!], $state: SpaceMembershipState, $visible: Boolean, $skip: Int, $limit: Int, $search: String, $sort: SortInput, $deletion: Boolean, $tags: [MongoID!]) {\n  listSpaceMembers(\n    space: $space\n    roles: $roles\n    state: $state\n    visible: $visible\n    skip: $skip\n    limit: $limit\n    search: $search\n    sort: $sort\n    deletion: $deletion\n    tags: $tags\n  ) {\n    total\n    items {\n      _id\n      user\n      user_name\n      email\n      space\n      role\n      state\n      visible\n      role_changed_at\n      deleted_at\n      user_expanded {\n        _id\n        name\n        display_name\n        email\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      event_count\n      checkin_count\n      tags {\n        _id\n        space\n        tag\n        color\n        type\n        targets\n        targets_count\n      }\n    }\n  }\n}\n\nmutation FollowSpace($space: MongoID!) {\n  followSpace(space: $space)\n}\n\nmutation UnfollowSpace($space: MongoID!) {\n  unfollowSpace(space: $space)\n}\n\nmutation UpdateSpace($id: MongoID!, $input: SpaceInput!) {\n  updateSpace(_id: $id, input: $input) {\n    ...Space\n  }\n}\n\nmutation PinEventsToSpace($space: MongoID!, $events: [MongoID!]!, $tags: [MongoID!]) {\n  pinEventsToSpace(space: $space, events: $events, tags: $tags) {\n    requests {\n      ...SpaceEventRequestFragment\n    }\n  }\n}\n\nmutation CreateExternalEvent($input: EventInput!) {\n  createEvent(input: $input) {\n    _id\n  }\n}\n\nmutation CreateSpace($input: SpaceInput!) {\n  createSpace(input: $input) {\n    ...Space\n  }\n}\n\nmutation DecideSpaceEventRequests($input: DecideSpaceEventRequestsInput!) {\n  decideSpaceEventRequests(input: $input)\n}\n\nmutation AddSpaceMembers($input: AddSpaceMemberInput!) {\n  addSpaceMembers(input: $input)\n}\n\nmutation DeleteSpaceMembers($input: DeleteSpaceMemberInput!) {\n  deleteSpaceMembers(input: $input) {\n    _id\n    role\n    state\n    user\n    user_name\n    email\n    deleted_at\n    role_changed_at\n    user_expanded {\n      _id\n      name\n      email\n      image_avatar\n    }\n    visible\n  }\n}\n\nmutation DeleteSpace($id: MongoID!) {\n  deleteSpace(_id: $id)\n}\n\nmutation UpsertSpaceTag($input: SpaceTagInput!) {\n  insertSpaceTag(input: $input) {\n    ...SpaceTagFragment\n  }\n}\n\nmutation ManageSpaceTag($tagged: Boolean!, $target: String!, $id: MongoID!, $space: MongoID!) {\n  manageSpaceTag(tagged: $tagged, target: $target, _id: $id, space: $space)\n}\n\nmutation DeleteSpaceTag($id: MongoID!, $space: MongoID!) {\n  deleteSpaceTag(_id: $id, space: $space)\n}\n\nmutation AttachSubSpaces($id: MongoID!, $subSpaces: [String!]!) {\n  attachSubSpaces(_id: $id, sub_spaces: $subSpaces)\n}\n\nmutation RemoveSubSpaces($subSpaces: [MongoID!]!, $id: MongoID!) {\n  removeSubSpaces(sub_spaces: $subSpaces, _id: $id)\n}\n\nmutation UpdateSubSpaceOrder($id: MongoID!, $subSpaces: [MongoID!]!) {\n  updateSubSpaceOrder(_id: $id, sub_spaces: $subSpaces)\n}\n\nmutation UpsertSpaceTag($input: SpaceTagInput!) {\n  insertSpaceTag(input: $input) {\n    ...SpaceTagFragment\n  }\n}\n\nmutation DeleteSpaceTag($id: MongoID!, $space: MongoID!) {\n  deleteSpaceTag(_id: $id, space: $space)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query CalculateTicketsPricing($input: CalculateTicketsPricingInput!) {\n  calculateTicketsPricing(input: $input) {\n    deposit_infos {\n      minimum_amount\n      minimum_percent\n    }\n    discount\n    payment_accounts {\n      _id\n      account_info {\n        ... on SolanaAccount {\n          currencies\n          currency_map\n          address\n          network\n        }\n        ... on EthereumAccount {\n          currencies\n          currency_map\n          address\n          network\n        }\n        ... on SafeAccount {\n          currencies\n          currency_map\n          address\n          network\n          owners\n          threshold\n          pending\n        }\n        ... on DigitalAccount {\n          currencies\n          currency_map\n          account_id\n        }\n        ... on StripeAccount {\n          currencies\n          currency_map\n          account_id\n          publishable_key\n        }\n        ... on EthereumEscrowAccount {\n          currencies\n          currency_map\n          address\n          network\n          minimum_deposit_percent\n          host_refund_percent\n          refund_policies {\n            percent\n            timestamp\n          }\n        }\n        ... on EthereumRelayAccount {\n          currencies\n          currency_map\n          address\n          network\n          payment_splitter_contract\n        }\n        ... on EthereumStakeAccount {\n          currencies\n          currency_map\n          address\n          network\n          config_id\n          requirement_checkin_before\n        }\n      }\n      active\n      created_at\n      escrow {\n        minimum_amount\n        minimum_percent\n      }\n      fee\n      provider\n      relay {\n        payment_splitter_contract\n      }\n      title\n      type\n      user\n    }\n    subtotal\n    total\n  }\n}\n\nquery getMyTickets($event: MongoID!, $withPaymentInfo: Boolean) {\n  getMyTickets(event: $event, with_payment_info: $withPaymentInfo) {\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      assigned_to_expanded {\n        _id\n        name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      event\n      invited_by\n      type\n      type_expanded {\n        _id\n        title\n        prices {\n          cost\n          currency\n          default\n          payment_accounts\n          payment_accounts_expanded {\n            ...PaymentAccount\n          }\n        }\n      }\n      shortid\n      event_expanded {\n        _id\n        title\n      }\n    }\n    payments {\n      _id\n      state\n      amount\n      attempting_refund\n      currency\n      refund_info {\n        available_amount\n        refunded\n      }\n      refund_policy {\n        percent\n        requirements {\n          checkin_before\n        }\n        satisfy_all\n      }\n      refund_requirements_met\n      payment_account {\n        _id\n        account_info {\n          ... on EthereumStakeAccount {\n            currencies\n            currency_map\n            address\n            network\n            config_id\n            requirement_checkin_before\n          }\n        }\n        type\n      }\n    }\n  }\n}\n\nmutation redeemTickets($event: MongoID!, $items: [PurchasableItem!]!, $buyer_info: BuyerInfoInput, $inviter: MongoID, $user_info: UserInput, $connect_wallets: [ConnectWalletInput!], $buyer_wallet: String, $passcodes: [String!]) {\n  redeemTickets(\n    input: {event: $event, items: $items, buyer_info: $buyer_info, inviter: $inviter, user_info: $user_info, connect_wallets: $connect_wallets, buyer_wallet: $buyer_wallet, passcodes: $passcodes}\n  ) {\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    join_request {\n      _id\n      state\n    }\n  }\n}\n\nmutation AssignTickets($input: AssignTicketsInput!) {\n  assignTickets(input: $input)\n}\n\nmutation buyTickets($input: BuyTicketsInput!) {\n  buyTickets(input: $input) {\n    payment {\n      _id\n      failure_reason\n      state\n      stamps\n      transfer_metadata\n    }\n    join_request {\n      _id\n      state\n    }\n  }\n}\n\nmutation createEventTicketType($input: EventTicketTypeInput!) {\n  createEventTicketType(input: $input) {\n    _id\n    active\n    private\n    default\n    description\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    ticket_limit\n    title\n    limited\n    limited_whitelist_users {\n      _id\n      email\n    }\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nmutation deleteEventTicketType($event: MongoID!, $id: MongoID!) {\n  deleteEventTicketType(event: $event, _id: $id)\n}\n\nmutation updateEventTicketType($input: EventTicketTypeInput!, $id: MongoID!) {\n  updateEventTicketType(input: $input, _id: $id) {\n    _id\n    active\n    default\n    private\n    description\n    event\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    ticket_limit\n    title\n    offers {\n      _id\n      auto\n      broadcast_rooms\n      position\n      provider\n      provider_id\n      provider_network\n    }\n    limited\n    limited_whitelist_users {\n      _id\n      email\n    }\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nquery exportEventTickets($id: MongoID!, $ticketTypeIds: [MongoID!], $searchText: String, $pagination: PaginationInput, $checkedIn: Boolean) {\n  exportEventTickets(\n    _id: $id\n    ticket_type_ids: $ticketTypeIds\n    search_text: $searchText\n    pagination: $pagination\n    checked_in: $checkedIn\n  ) {\n    count\n    tickets {\n      _id\n      buyer_name\n      buyer_first_name\n      buyer_last_name\n      buyer_email\n      ticket_category\n      ticket_type\n      quantity\n      payment_amount\n      discount_amount\n      currency\n      discount_code\n      purchase_date\n      payment_provider\n      payment_id\n      checkin_date\n      is_assigned\n      assignee_email\n      assigned_to\n      assigned_email\n      is_issued\n      issued_by\n      is_claimed\n      active\n      cancelled_by\n      buyer_wallet\n      buyer_id\n      buyer_avatar\n      buyer_username\n      ticket_type_id\n      shortid\n    }\n  }\n}\n\nmutation CreateTickets($ticketType: MongoID!, $ticketAssignments: [TicketAssignment!]!) {\n  createTickets(ticket_type: $ticketType, ticket_assignments: $ticketAssignments) {\n    _id\n  }\n}\n\nquery CheckTicketTypePasscode($passcode: String!, $type: MongoID!) {\n  checkTicketTypePasscode(passcode: $passcode, type: $type)\n}"): (typeof documents)["query CalculateTicketsPricing($input: CalculateTicketsPricingInput!) {\n  calculateTicketsPricing(input: $input) {\n    deposit_infos {\n      minimum_amount\n      minimum_percent\n    }\n    discount\n    payment_accounts {\n      _id\n      account_info {\n        ... on SolanaAccount {\n          currencies\n          currency_map\n          address\n          network\n        }\n        ... on EthereumAccount {\n          currencies\n          currency_map\n          address\n          network\n        }\n        ... on SafeAccount {\n          currencies\n          currency_map\n          address\n          network\n          owners\n          threshold\n          pending\n        }\n        ... on DigitalAccount {\n          currencies\n          currency_map\n          account_id\n        }\n        ... on StripeAccount {\n          currencies\n          currency_map\n          account_id\n          publishable_key\n        }\n        ... on EthereumEscrowAccount {\n          currencies\n          currency_map\n          address\n          network\n          minimum_deposit_percent\n          host_refund_percent\n          refund_policies {\n            percent\n            timestamp\n          }\n        }\n        ... on EthereumRelayAccount {\n          currencies\n          currency_map\n          address\n          network\n          payment_splitter_contract\n        }\n        ... on EthereumStakeAccount {\n          currencies\n          currency_map\n          address\n          network\n          config_id\n          requirement_checkin_before\n        }\n      }\n      active\n      created_at\n      escrow {\n        minimum_amount\n        minimum_percent\n      }\n      fee\n      provider\n      relay {\n        payment_splitter_contract\n      }\n      title\n      type\n      user\n    }\n    subtotal\n    total\n  }\n}\n\nquery getMyTickets($event: MongoID!, $withPaymentInfo: Boolean) {\n  getMyTickets(event: $event, with_payment_info: $withPaymentInfo) {\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      assigned_to_expanded {\n        _id\n        name\n        new_photos_expanded(limit: 1) {\n          _id\n          key\n          bucket\n        }\n      }\n      event\n      invited_by\n      type\n      type_expanded {\n        _id\n        title\n        prices {\n          cost\n          currency\n          default\n          payment_accounts\n          payment_accounts_expanded {\n            ...PaymentAccount\n          }\n        }\n      }\n      shortid\n      event_expanded {\n        _id\n        title\n      }\n    }\n    payments {\n      _id\n      state\n      amount\n      attempting_refund\n      currency\n      refund_info {\n        available_amount\n        refunded\n      }\n      refund_policy {\n        percent\n        requirements {\n          checkin_before\n        }\n        satisfy_all\n      }\n      refund_requirements_met\n      payment_account {\n        _id\n        account_info {\n          ... on EthereumStakeAccount {\n            currencies\n            currency_map\n            address\n            network\n            config_id\n            requirement_checkin_before\n          }\n        }\n        type\n      }\n    }\n  }\n}\n\nmutation redeemTickets($event: MongoID!, $items: [PurchasableItem!]!, $buyer_info: BuyerInfoInput, $inviter: MongoID, $user_info: UserInput, $connect_wallets: [ConnectWalletInput!], $buyer_wallet: String, $passcodes: [String!]) {\n  redeemTickets(\n    input: {event: $event, items: $items, buyer_info: $buyer_info, inviter: $inviter, user_info: $user_info, connect_wallets: $connect_wallets, buyer_wallet: $buyer_wallet, passcodes: $passcodes}\n  ) {\n    tickets {\n      _id\n      accepted\n      assigned_email\n      assigned_to\n      event\n      invited_by\n      type\n    }\n    join_request {\n      _id\n      state\n    }\n  }\n}\n\nmutation AssignTickets($input: AssignTicketsInput!) {\n  assignTickets(input: $input)\n}\n\nmutation buyTickets($input: BuyTicketsInput!) {\n  buyTickets(input: $input) {\n    payment {\n      _id\n      failure_reason\n      state\n      stamps\n      transfer_metadata\n    }\n    join_request {\n      _id\n      state\n    }\n  }\n}\n\nmutation createEventTicketType($input: EventTicketTypeInput!) {\n  createEventTicketType(input: $input) {\n    _id\n    active\n    private\n    default\n    description\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    ticket_limit\n    title\n    limited\n    limited_whitelist_users {\n      _id\n      email\n    }\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nmutation deleteEventTicketType($event: MongoID!, $id: MongoID!) {\n  deleteEventTicketType(event: $event, _id: $id)\n}\n\nmutation updateEventTicketType($input: EventTicketTypeInput!, $id: MongoID!) {\n  updateEventTicketType(input: $input, _id: $id) {\n    _id\n    active\n    default\n    private\n    description\n    event\n    photos\n    photos_expanded {\n      _id\n      bucket\n      key\n    }\n    prices {\n      cost\n      currency\n      default\n      payment_accounts\n      payment_accounts_expanded {\n        ...PaymentAccount\n      }\n    }\n    ticket_limit\n    title\n    offers {\n      _id\n      auto\n      broadcast_rooms\n      position\n      provider\n      provider_id\n      provider_network\n    }\n    limited\n    limited_whitelist_users {\n      _id\n      email\n    }\n    category\n    category_expanded {\n      _id\n      description\n      title\n      position\n    }\n    position\n  }\n}\n\nquery exportEventTickets($id: MongoID!, $ticketTypeIds: [MongoID!], $searchText: String, $pagination: PaginationInput, $checkedIn: Boolean) {\n  exportEventTickets(\n    _id: $id\n    ticket_type_ids: $ticketTypeIds\n    search_text: $searchText\n    pagination: $pagination\n    checked_in: $checkedIn\n  ) {\n    count\n    tickets {\n      _id\n      buyer_name\n      buyer_first_name\n      buyer_last_name\n      buyer_email\n      ticket_category\n      ticket_type\n      quantity\n      payment_amount\n      discount_amount\n      currency\n      discount_code\n      purchase_date\n      payment_provider\n      payment_id\n      checkin_date\n      is_assigned\n      assignee_email\n      assigned_to\n      assigned_email\n      is_issued\n      issued_by\n      is_claimed\n      active\n      cancelled_by\n      buyer_wallet\n      buyer_id\n      buyer_avatar\n      buyer_username\n      ticket_type_id\n      shortid\n    }\n  }\n}\n\nmutation CreateTickets($ticketType: MongoID!, $ticketAssignments: [TicketAssignment!]!) {\n  createTickets(ticket_type: $ticketType, ticket_assignments: $ticketAssignments) {\n    _id\n  }\n}\n\nquery CheckTicketTypePasscode($passcode: String!, $type: MongoID!) {\n  checkTicketTypePasscode(passcode: $passcode, type: $type)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetMe {\n  getMe {\n    ...User\n    email\n    email_verified\n    wallets_new\n    wallet_custodial\n    stripe_connected_account {\n      account_id\n      connected\n    }\n    kratos_wallet_address\n    kratos_farcaster_fid\n    kratos_unicorn_wallet_address\n    oauth2_allow_creation\n    oauth2_clients\n    oauth2_max_clients\n  }\n}\n\nmutation SetUserWallet($token: String!, $signature: String!) {\n  setUserWallet(token: $token, signature: $signature)\n}\n\nmutation UpdateUser($input: UserInput!) {\n  updateUser(input: $input) {\n    ...User\n  }\n}\n\nquery SearchUsers($query: String!) {\n  searchUsers(query: $query) {\n    _id\n    email\n    name\n    display_name\n    new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n    }\n  }\n}\n\nquery GetUser($id: MongoID, $username: String, $email: String, $lens_profile_id: String) {\n  getUser(\n    _id: $id\n    username: $username\n    email: $email\n    lens_profile_id: $lens_profile_id\n  ) {\n    _id\n    name\n    display_name\n    email\n    username\n    description\n    followers\n    following\n    hosted\n    addresses {\n      _id\n      street_1\n      street_2\n      city\n      region\n      postal\n      country\n      title\n      phone\n      longitude\n      latitude\n      additional_directions\n    }\n    new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n    }\n    cover_expanded {\n      _id\n      bucket\n      url\n      type\n      key\n    }\n    handle_facebook\n    handle_instagram\n    handle_linkedin\n    handle_twitter\n    handle_farcaster\n    handle_github\n    created_at\n  }\n}\n\nmutation deleteUser {\n  deleteUser\n}\n\nmutation syncUserUnicornWallet {\n  syncUserUnicornWallet\n}\n\nquery UsernameAvailability($wallet: String!, $username: String!) {\n  isUsernameAvailable(wallet: $wallet, username: $username)\n}"): (typeof documents)["query GetMe {\n  getMe {\n    ...User\n    email\n    email_verified\n    wallets_new\n    wallet_custodial\n    stripe_connected_account {\n      account_id\n      connected\n    }\n    kratos_wallet_address\n    kratos_farcaster_fid\n    kratos_unicorn_wallet_address\n    oauth2_allow_creation\n    oauth2_clients\n    oauth2_max_clients\n  }\n}\n\nmutation SetUserWallet($token: String!, $signature: String!) {\n  setUserWallet(token: $token, signature: $signature)\n}\n\nmutation UpdateUser($input: UserInput!) {\n  updateUser(input: $input) {\n    ...User\n  }\n}\n\nquery SearchUsers($query: String!) {\n  searchUsers(query: $query) {\n    _id\n    email\n    name\n    display_name\n    new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n    }\n  }\n}\n\nquery GetUser($id: MongoID, $username: String, $email: String, $lens_profile_id: String) {\n  getUser(\n    _id: $id\n    username: $username\n    email: $email\n    lens_profile_id: $lens_profile_id\n  ) {\n    _id\n    name\n    display_name\n    email\n    username\n    description\n    followers\n    following\n    hosted\n    addresses {\n      _id\n      street_1\n      street_2\n      city\n      region\n      postal\n      country\n      title\n      phone\n      longitude\n      latitude\n      additional_directions\n    }\n    new_photos_expanded(limit: 1) {\n      _id\n      key\n      bucket\n    }\n    cover_expanded {\n      _id\n      bucket\n      url\n      type\n      key\n    }\n    handle_facebook\n    handle_instagram\n    handle_linkedin\n    handle_twitter\n    handle_farcaster\n    handle_github\n    created_at\n  }\n}\n\nmutation deleteUser {\n  deleteUser\n}\n\nmutation syncUserUnicornWallet {\n  syncUserUnicornWallet\n}\n\nquery UsernameAvailability($wallet: String!, $username: String!) {\n  isUsernameAvailable(wallet: $wallet, username: $username)\n}"];

export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;